<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WarnerMapper v2</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            --bg-primary: #0a0f1a;
            --bg-secondary: #0d1525;
            --bg-card: #111827;
            --bg-card-hover: #1a2337;
            --accent-blue: #3b82f6;
            --accent-blue-light: #60a5fa;
            --accent-blue-glow: rgba(59, 130, 246, 0.5);
            --accent-yellow: #fbbf24;
            --accent-yellow-light: #fcd34d;
            --accent-yellow-glow: rgba(251, 191, 36, 0.5);
            --accent-orange: #f59e0b;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border-color: rgba(255, 255, 255, 0.08);
            --border-glow: rgba(251, 191, 36, 0.3);
            --success-green: #10b981;
            --success-glow: rgba(16, 185, 129, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            background-image: 
                radial-gradient(ellipse at 10% 20%, rgba(59, 130, 246, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 90% 80%, rgba(251, 191, 36, 0.06) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(59, 130, 246, 0.03) 0%, transparent 70%);
            min-height: 100vh;
            padding: 20px;
            color: var(--text-primary);
            overflow-x: hidden;
        }

        /* Animated particle background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20px 30px, rgba(251, 191, 36, 0.6), transparent),
                radial-gradient(1.5px 1.5px at 40px 70px, rgba(59, 130, 246, 0.55), transparent),
                radial-gradient(1px 1px at 90px 40px, rgba(255, 255, 255, 0.5), transparent),
                radial-gradient(2px 2px at 130px 80px, rgba(251, 191, 36, 0.55), transparent),
                radial-gradient(1.5px 1.5px at 160px 120px, rgba(59, 130, 246, 0.6), transparent),
                radial-gradient(1px 1px at 60px 140px, rgba(255, 255, 255, 0.45), transparent),
                radial-gradient(1.5px 1.5px at 100px 160px, rgba(251, 191, 36, 0.5), transparent),
                radial-gradient(2px 2px at 180px 50px, rgba(59, 130, 246, 0.5), transparent),
                radial-gradient(1px 1px at 15px 90px, rgba(251, 191, 36, 0.55), transparent),
                radial-gradient(1.5px 1.5px at 75px 110px, rgba(59, 130, 246, 0.5), transparent),
                radial-gradient(2px 2px at 140px 25px, rgba(255, 255, 255, 0.45), transparent),
                radial-gradient(1px 1px at 195px 145px, rgba(251, 191, 36, 0.6), transparent);
            background-size: 200px 200px;
            animation: particleDrift1 30s ease-in-out infinite alternate;
            pointer-events: none;
            z-index: 0;
            opacity: 0.7;
        }

        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(1.5px 1.5px at 80px 20px, rgba(251, 191, 36, 0.55), transparent),
                radial-gradient(1px 1px at 120px 90px, rgba(59, 130, 246, 0.5), transparent),
                radial-gradient(2px 2px at 30px 150px, rgba(255, 255, 255, 0.45), transparent),
                radial-gradient(1.5px 1.5px at 170px 130px, rgba(251, 191, 36, 0.6), transparent),
                radial-gradient(1px 1px at 50px 60px, rgba(59, 130, 246, 0.55), transparent),
                radial-gradient(2px 2px at 110px 45px, rgba(255, 255, 255, 0.5), transparent),
                radial-gradient(1.5px 1.5px at 25px 180px, rgba(251, 191, 36, 0.5), transparent),
                radial-gradient(1px 1px at 150px 70px, rgba(59, 130, 246, 0.6), transparent),
                radial-gradient(1.5px 1.5px at 85px 175px, rgba(255, 255, 255, 0.45), transparent),
                radial-gradient(2px 2px at 190px 100px, rgba(251, 191, 36, 0.55), transparent);
            background-size: 250px 250px;
            animation: particleDrift2 40s ease-in-out infinite alternate-reverse;
            pointer-events: none;
            z-index: 0;
            opacity: 0.6;
        }

        @keyframes particleDrift1 {
            0% { transform: translate(0, 0); }
            25% { transform: translate(15px, -20px); }
            50% { transform: translate(-10px, 15px); }
            75% { transform: translate(20px, 10px); }
            100% { transform: translate(-15px, -15px); }
        }

        @keyframes particleDrift2 {
            0% { transform: translate(0, 0); }
            33% { transform: translate(-20px, 15px); }
            66% { transform: translate(15px, -10px); }
            100% { transform: translate(-10px, 20px); }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .header {
            margin-bottom: 40px;
            border-radius: 20px;
            overflow: hidden;
            position: relative;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 40px rgba(59, 130, 246, 0.1);
            border: 1px solid var(--border-color);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .header:hover {
            box-shadow: 
                0 30px 60px -15px rgba(0, 0, 0, 0.6),
                0 0 60px rgba(251, 191, 36, 0.15);
            transform: translateY(-2px);
        }

        .header img {
            width: 100%;
            height: auto;
            display: block;
            object-fit: cover;
        }

        /* Drop Zone */
        .drop-zone {
            background: linear-gradient(145deg, var(--bg-card), var(--bg-secondary));
            border: 2px dashed var(--accent-yellow);
            border-radius: 20px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            margin-bottom: 30px;
            box-shadow: 
                0 20px 40px -10px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
        }

        .drop-zone::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(251, 191, 36, 0.1), transparent);
            transition: left 0.6s ease;
        }

        .drop-zone:hover::before {
            left: 100%;
        }

        .drop-zone:hover {
            border-color: var(--accent-blue);
            background: linear-gradient(145deg, var(--bg-card-hover), var(--bg-card));
            transform: translateY(-5px) scale(1.01);
            box-shadow: 
                0 30px 60px -15px rgba(0, 0, 0, 0.5),
                0 0 40px var(--accent-blue-glow);
        }

        .drop-zone.dragover {
            background: linear-gradient(145deg, rgba(59, 130, 246, 0.15), var(--bg-card));
            border-color: var(--accent-blue-light);
            transform: scale(1.02);
            box-shadow: 
                0 35px 70px -20px rgba(0, 0, 0, 0.6),
                0 0 60px var(--accent-blue-glow);
        }

        .drop-zone p {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
        }

        .drop-zone .icon {
            font-size: 3.5rem;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 20px var(--accent-yellow-glow));
            animation: iconFloat 3s ease-in-out infinite;
        }

        @keyframes iconFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }

        /* Panels */
        .mapping-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 30px;
        }

        .panel {
            background: linear-gradient(145deg, var(--bg-card), var(--bg-secondary));
            border-radius: 16px;
            padding: 24px;
            box-shadow: 
                0 20px 40px -10px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-yellow), var(--accent-blue));
            background-size: 200% 100%;
            animation: borderGlow 3s linear infinite;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .panel:hover::before {
            opacity: 1;
        }

        .panel:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 25px 50px -15px rgba(0, 0, 0, 0.5),
                0 0 30px rgba(59, 130, 246, 0.1);
        }

        @keyframes borderGlow {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        .panel h2 {
            color: var(--text-primary);
            margin-bottom: 20px;
            font-size: 1.25rem;
            font-weight: 600;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel h2::before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(180deg, var(--accent-yellow), var(--accent-blue));
            border-radius: 2px;
        }

        /* Movie Poster Panel */
        .poster-panel {
            display: flex;
            flex-direction: column;
        }

        .poster-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 450px;
            background: var(--bg-secondary);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            padding: 20px;
        }

        .poster-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            text-align: center;
            padding: 40px;
        }

        .poster-placeholder .poster-icon {
            font-size: 4rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .poster-placeholder p {
            font-size: 0.95rem;
        }

        .poster-image {
            max-width: calc(100% - 20px);
            max-height: 480px;
            width: auto;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }

        .poster-image:hover {
            transform: scale(1.03);
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.6), 0 0 30px var(--accent-blue-glow);
        }

        .poster-link {
            display: block;
            text-decoration: none;
        }

        .poster-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            color: var(--text-secondary);
        }

        .poster-loading .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--bg-card);
            border-top-color: var(--accent-yellow);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .poster-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--text-muted);
            text-align: center;
            padding: 40px;
        }

        .poster-error .error-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .movie-info {
            margin-top: 10px;
            text-align: center;
            padding: 5px 10px;
        }

        .movie-info .movie-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 3px;
        }

        .movie-info .movie-year {
            font-size: 0.85rem;
            color: var(--accent-yellow);
        }

        /* Cast & Crew Validation */
        .validation-list {
            max-height: 500px;
            overflow-y: auto;
            padding-right: 8px;
        }

        .validation-list::-webkit-scrollbar {
            width: 6px;
        }

        .validation-list::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 3px;
        }

        .validation-list::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--accent-yellow), var(--accent-blue));
            border-radius: 3px;
        }

        .validation-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            text-align: center;
            padding: 50px 40px;
            gap: 15px;
        }

        .validation-placeholder .validation-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .validation-placeholder .tmdb-logo {
            width: 80px;
            height: auto;
            opacity: 0.6;
            transition: opacity 0.3s ease;
        }

        .validation-placeholder p {
            font-size: 0.9rem;
            margin: 5px 0 15px 0;
        }

        .validation-btn-main {
            padding: 10px 24px;
            font-size: 0.85rem;
            font-weight: 600;
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            background: rgba(59, 130, 246, 0.1);
            color: var(--accent-blue);
            cursor: pointer;
            transition: all 0.25s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .validation-btn-main:hover:not(:disabled) {
            background: rgba(59, 130, 246, 0.2);
            border-color: var(--accent-blue);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.2);
        }

        .validation-btn-main:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .validation-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            margin-bottom: 6px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            transition: all 0.25s ease;
        }

        .validation-item:hover {
            background: rgba(255, 255, 255, 0.04);
            border-color: rgba(255, 255, 255, 0.12);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .validation-item.valid {
            border-color: rgba(16, 185, 129, 0.3);
            background: rgba(16, 185, 129, 0.03);
        }

        .validation-item.valid:hover {
            border-color: rgba(16, 185, 129, 0.5);
            background: rgba(16, 185, 129, 0.06);
            box-shadow: 0 2px 12px rgba(16, 185, 129, 0.1);
        }

        .validation-item.invalid {
            border-color: rgba(245, 158, 11, 0.3);
            background: rgba(245, 158, 11, 0.03);
        }

        .validation-item.invalid:hover {
            border-color: rgba(245, 158, 11, 0.5);
            background: rgba(245, 158, 11, 0.06);
            box-shadow: 0 2px 12px rgba(245, 158, 11, 0.1);
        }

        .validation-item.not-found {
            border-color: rgba(239, 68, 68, 0.3);
            background: rgba(239, 68, 68, 0.03);
        }

        .validation-item.not-found:hover {
            border-color: rgba(239, 68, 68, 0.5);
            background: rgba(239, 68, 68, 0.06);
            box-shadow: 0 2px 12px rgba(239, 68, 68, 0.1);
        }

        .validation-item.accent-warning {
            border-color: rgba(139, 92, 246, 0.3);
            background: rgba(139, 92, 246, 0.03);
        }

        .validation-item.accent-warning:hover {
            border-color: rgba(139, 92, 246, 0.5);
            background: rgba(139, 92, 246, 0.06);
            box-shadow: 0 2px 12px rgba(139, 92, 246, 0.1);
        }

        .validation-item.role-warning {
            border-color: rgba(251, 191, 36, 0.3);
            background: rgba(251, 191, 36, 0.03);
        }

        .validation-item.role-warning:hover {
            border-color: rgba(251, 191, 36, 0.5);
            background: rgba(251, 191, 36, 0.06);
            box-shadow: 0 2px 12px rgba(251, 191, 36, 0.1);
        }

        .validation-status {
            font-size: 1rem;
            flex-shrink: 0;
            width: 24px;
            text-align: center;
        }

        .validation-name {
            flex: 1;
            font-size: 0.9rem;
        }

        .validation-name .excel-name {
            color: var(--text-primary);
            font-weight: 500;
        }

        .validation-name .tmdb-name {
            color: #8b5cf6;
            font-size: 0.8rem;
            margin-top: 2px;
        }

        /* Override tmdb-name color for invalid/similar state */
        .validation-item.invalid .tmdb-name {
            color: #fbbf24;
        }

        /* Override tmdb-name color for not-found state */
        .validation-item.not-found .tmdb-name {
            color: #f87171;
        }

        .validation-name .tmdb-match {
            color: #10b981;
            font-size: 0.75rem;
            margin-top: 2px;
            opacity: 0.8;
        }

        .validation-name .tmdb-role {
            color: #10b981;
            font-size: 0.7rem;
            opacity: 0.7;
        }

        /* Override tmdb-role color for different states */
        .validation-item.accent-warning .tmdb-role {
            color: #a78bfa;
        }

        .validation-item.invalid .tmdb-role {
            color: #fbbf24;
        }

        .validation-name .tmdb-role-diff {
            color: #fbbf24;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .validation-name .tmdb-suggestion {
            color: #10b981;
            font-size: 0.75rem;
            margin-top: 4px;
        }

        .validation-name .tmdb-suggestion strong {
            color: #34d399;
        }

        .validation-name .character-name {
            color: var(--text-muted);
            font-size: 0.8rem;
            font-style: italic;
            margin-top: 2px;
        }

        .validation-name .role {
            color: var(--accent-blue);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .role-tag {
            display: inline-block;
            font-size: 0.65rem;
            font-weight: 500;
            color: #93c5fd;
            background: rgba(59, 130, 246, 0.15);
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            vertical-align: middle;
        }

        .status-ok {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(16, 185, 129, 0.15);
            border: 1.5px solid rgba(16, 185, 129, 0.5);
            color: #10b981;
            font-size: 0.7rem;
            font-weight: 700;
        }

        .validation-action {
            flex-shrink: 0;
        }

        .validation-action-multi {
            display: flex;
            gap: 6px;
        }

        .validation-btn {
            padding: 4px 10px;
            font-size: 0.7rem;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .validation-btn.fix {
            background: rgba(139, 92, 246, 0.2);
            color: #a78bfa;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .validation-btn.fix:hover {
            background: rgba(139, 92, 246, 0.4);
            border-color: #8b5cf6;
        }

        .validation-btn.fix-role {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .validation-btn.fix-role:hover {
            background: rgba(251, 191, 36, 0.4);
            border-color: #fbbf24;
        }

        .validation-btn.delete {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .validation-btn.delete:hover {
            background: rgba(239, 68, 68, 0.4);
            border-color: #ef4444;
        }

        .validation-btn.add {
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .validation-btn.add:hover {
            background: rgba(59, 130, 246, 0.4);
            border-color: #3b82f6;
        }

        .validation-btn.applied {
            background: rgba(16, 185, 129, 0.2);
            color: #34d399;
            border: 1px solid rgba(16, 185, 129, 0.3);
            cursor: default;
        }

        .validation-item.suggestion {
            background: rgba(59, 130, 246, 0.08);
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .validation-item.suggestion .validation-status {
            color: #60a5fa;
            font-weight: bold;
        }

        .validation-subsection {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px dashed rgba(255, 255, 255, 0.1);
        }

        .validation-subsection-title {
            font-size: 0.7rem;
            color: #60a5fa;
            margin-bottom: 8px;
            padding-left: 5px;
        }

        .validation-section {
            margin-bottom: 15px;
        }

        .validation-section-title {
            font-size: 0.8rem;
            color: var(--accent-yellow);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            padding-left: 5px;
        }

        .validation-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 40px;
            color: var(--text-secondary);
        }

        .validation-loading .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid var(--bg-card);
            border-top-color: var(--accent-yellow);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Scrollbar */
        .mapping-list {
            max-height: 500px;
            overflow-y: auto;
            padding-right: 8px;
        }

        .mapping-list::-webkit-scrollbar {
            width: 6px;
        }

        .mapping-list::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 3px;
        }

        .mapping-list::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--accent-yellow), var(--accent-blue));
            border-radius: 3px;
            transition: all 0.3s ease;
        }

        .mapping-list::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, var(--accent-blue), var(--accent-yellow));
        }

        /* Mapping Items */
        .mapping-item {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            padding: 12px 16px;
            margin-bottom: 8px;
            background: var(--bg-secondary);
            border-radius: 10px;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid transparent;
            position: relative;
        }

        .mapping-item::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 10px;
            padding: 1px;
            background: linear-gradient(135deg, transparent, transparent);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mapping-item:hover {
            background: var(--bg-card-hover);
            transform: translateX(8px);
            border-color: var(--accent-yellow);
            box-shadow: 0 4px 20px rgba(251, 191, 36, 0.15);
        }

        .mapping-item:hover::after {
            background: linear-gradient(135deg, var(--accent-yellow), var(--accent-blue));
            opacity: 1;
        }

        .mapping-item .excel-field {
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .mapping-item .arrow {
            margin: 0 12px;
            color: var(--accent-yellow);
            font-size: 1.1rem;
            transition: transform 0.3s ease;
        }

        .mapping-item:hover .arrow {
            transform: translateX(3px);
            text-shadow: 0 0 10px var(--accent-yellow-glow);
        }

        .mapping-item select {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.25s ease;
            font-size: 0.85rem;
            font-family: inherit;
        }

        .mapping-item select:hover {
            border-color: var(--accent-yellow);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.2);
        }

        .mapping-item select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px var(--accent-blue-glow);
        }

        /* Buttons */
        .button-group {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            padding: 14px 32px;
            font-size: 0.95rem;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            position: relative;
            overflow: hidden;
            font-family: inherit;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
        }

        button:active::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-yellow) 0%, var(--accent-orange) 100%);
            color: var(--bg-primary);
            box-shadow: 
                0 8px 30px rgba(251, 191, 36, 0.35),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .btn-primary:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 
                0 15px 40px rgba(251, 191, 36, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            filter: brightness(1.1);
        }

        .btn-primary:active {
            transform: translateY(-2px) scale(1.01);
        }

        .btn-secondary {
            background: linear-gradient(145deg, var(--bg-card), var(--bg-secondary));
            color: var(--text-primary);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: linear-gradient(145deg, var(--bg-card-hover), var(--bg-card));
            transform: translateY(-4px);
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.4),
                0 0 20px rgba(59, 130, 246, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
            border-color: var(--accent-blue);
        }

        .btn-success {
            background: rgba(59, 130, 246, 0.15);
            color: var(--accent-blue-light);
            border: 1px solid rgba(59, 130, 246, 0.4);
            box-shadow: 0 4px 15px var(--accent-blue-glow);
        }

        .btn-success:hover {
            background: rgba(59, 130, 246, 0.25);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
            border-color: var(--accent-blue);
        }

        /* Output Container */
        .output-container {
            background: linear-gradient(145deg, var(--bg-card), var(--bg-secondary));
            border-radius: 16px;
            padding: 24px;
            box-shadow: 
                0 20px 40px -10px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .output-container .backdrop-image {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0.18;
            pointer-events: none;
            z-index: 0;
            transition: opacity 0.5s ease;
        }

        .output-container .output-content {
            position: relative;
            z-index: 1;
        }

        .output-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-yellow));
        }

        .output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 15px;
        }

        .output-container h2 {
            color: var(--text-primary);
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .output-container h2::before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(180deg, var(--accent-blue), var(--accent-yellow));
            border-radius: 2px;
        }

        .output-title-row {
            display: flex;
            align-items: center;
            gap: 25px;
        }

        .btn-tmdb-validate {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(1, 180, 228, 0.15);
            border: 1px solid rgba(1, 180, 228, 0.4);
            border-radius: 8px;
            color: #01b4e4;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-tmdb-validate:hover {
            background: rgba(1, 180, 228, 0.25);
            border-color: #01b4e4;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(1, 180, 228, 0.3);
        }

        .btn-tmdb-validate .tmdb-logo {
            height: 14px;
            width: auto;
        }

        /* Toggle Switch */
        .schema-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .toggle-switch {
            position: relative;
            width: 56px;
            height: 28px;
            background: var(--bg-secondary);
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid var(--border-color);
        }

        .toggle-switch:hover {
            border-color: var(--accent-blue);
            box-shadow: 0 0 15px var(--accent-blue-glow);
        }

        .toggle-switch.active {
            background: linear-gradient(135deg, var(--accent-yellow), var(--accent-orange));
            border-color: var(--accent-yellow);
            box-shadow: 0 0 20px var(--accent-yellow-glow);
        }

        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(28px);
        }

        .schema-label {
            color: var(--accent-yellow);
            font-weight: 600;
            min-width: 35px;
            text-align: center;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .schema-label:first-of-type {
            color: var(--text-muted);
        }

        .toggle-switch.active ~ .schema-label:last-of-type {
            text-shadow: 0 0 10px var(--accent-yellow-glow);
        }

        /* Code Preview */
        pre {
            background: rgba(15, 23, 42, 0.75);
            padding: 20px;
            border-radius: 12px;
            overflow-x: auto;
            font-size: 0.85rem;
            line-height: 1.6;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            max-height: 600px;
            overflow-y: auto;
            white-space: pre;
            word-wrap: normal;
            backdrop-filter: blur(2px);
        }

        pre::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        pre::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 3px;
        }

        pre::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--accent-blue), var(--accent-yellow));
            border-radius: 3px;
        }

        /* XML Syntax Highlighting */
        .xml-tag { color: var(--accent-yellow); }
        .xml-attr-name { color: var(--accent-blue-light); }
        .xml-attr-value { color: var(--success-green); }
        .xml-text { color: #f1f5f9; } /* Bright white for maximum readability */
        .xml-comment { color: var(--text-muted); font-style: italic; }
        .xml-declaration { color: var(--accent-blue); }

        .hidden { display: none; }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .mode-label {
            color: var(--text-muted);
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .mode-label.active {
            color: var(--accent-yellow);
            text-shadow: 0 0 10px var(--accent-yellow-glow);
        }

        /* XML Output Wrapper for overlay editing */
        .xml-output-wrapper {
            position: relative;
            min-height: 400px;
            max-height: 600px;
            background: transparent;
        }

        .xml-output-wrapper pre {
            margin: 0;
            min-height: 400px;
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(2px);
        }

        .xml-output-wrapper.edit-mode pre {
            pointer-events: none;
        }

        /* XML Editor Textarea - overlay on pre */
        .xml-editor {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            min-height: 400px;
            max-height: 600px;
            background: transparent;
            color: transparent;
            caret-color: var(--accent-yellow);
            border: 2px solid var(--accent-blue);
            border-radius: 12px;
            padding: 20px;
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            resize: none;
            outline: none;
            overflow: auto;
            white-space: pre;
            word-wrap: normal;
            z-index: 2;
            box-shadow: 0 0 0 3px var(--accent-blue-glow);
        }

        .xml-editor::selection {
            background: rgba(59, 130, 246, 0.4);
        }

        .xml-editor::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .xml-editor::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 3px;
        }

        .xml-editor::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--accent-blue), var(--accent-yellow));
            border-radius: 3px;
        }

        /* Row Selector */
        .row-selector {
            margin-bottom: 20px;
            padding: 16px 20px;
            background: linear-gradient(145deg, var(--bg-card), var(--bg-secondary));
            border-radius: 12px;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .row-selector label {
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .row-selector select {
            padding: 10px 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            min-width: 250px;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.25s ease;
        }

        .row-selector select:hover {
            border-color: var(--accent-yellow);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.2);
        }

        .row-selector select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px var(--accent-blue-glow);
        }

        /* Status Classes */
        .auto-mapped {
            background: linear-gradient(145deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.08)) !important;
            border: 1px solid rgba(16, 185, 129, 0.3) !important;
        }

        .auto-mapped:hover {
            box-shadow: 0 4px 20px rgba(16, 185, 129, 0.2);
        }

        .manual-mapped {
            background: linear-gradient(145deg, rgba(251, 191, 36, 0.15), rgba(251, 191, 36, 0.08)) !important;
            border: 1px solid rgba(251, 191, 36, 0.3) !important;
        }

        .manual-mapped:hover {
            box-shadow: 0 4px 20px rgba(251, 191, 36, 0.2);
        }

        /* File Info */
        .file-info {
            background: linear-gradient(145deg, var(--bg-card), var(--bg-secondary));
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 15px;
        }

        .file-info span {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .file-info .filename {
            color: var(--accent-yellow);
            font-weight: 600;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
        }

        /* Animations */
        @keyframes fadeIn {
            from { 
                opacity: 0; 
                transform: translateY(15px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .fade-in {
            animation: fadeIn 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        @keyframes glow {
            0%, 100% { 
                box-shadow: 0 0 20px var(--accent-yellow-glow); 
            }
            50% { 
                box-shadow: 0 0 40px var(--accent-yellow-glow), 0 0 60px var(--accent-blue-glow); 
            }
        }

        /* Loading animation for buttons */
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        button.loading {
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        /* Responsive */
        @media (max-width: 900px) {
            .mapping-container {
                grid-template-columns: 1fr;
            }
            
            .output-header {
                flex-direction: column;
                align-items: flex-start;
            }
        }

        @media (max-width: 600px) {
            .button-group {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
            
            .row-selector {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .row-selector select {
                width: 100%;
                min-width: unset;
            }
        }
    </style>
</head>
<body>
    <div class="container">
		<div class="header">
			<img src="https://s14.gifyu.com/images/bTiBS.gif" alt="wbmapper (2)" />
		</div>
        
        <div class="drop-zone" id="dropZone">
            <div class="icon">üìÅ</div>
            <p>Drag and drop your Excel file here</p>
            <p style="font-size: 0.9rem; color: var(--text-muted);">or click to browse</p>
            <input type="file" id="fileInput" accept=".xlsx,.xls" style="display: none;">
        </div>

        <div id="fileInfo" class="file-info hidden">
            <span>Current file: <span class="filename" id="currentFileName"></span></span>
            <button class="btn-secondary" onclick="resetAll()">Load New File</button>
        </div>

        <div id="mappingSection" class="hidden">
            <div class="row-selector">
                <label for="rowSelect">Select Movie:</label>
                <select id="rowSelect"></select>
            </div>

            <div class="button-group">
                <button class="btn-secondary" onclick="resetMappings()">‚Üª Reset</button>
                <button class="btn-success" onclick="generateXML()">Generate iTunes XML</button>
            </div>

            <div class="mapping-container">
                <div class="panel fade-in poster-panel">
                    <div class="poster-container" id="posterContainer">
                        <div class="poster-placeholder">
                            <span class="poster-icon">üé¨</span>
                            <p>Select a movie to display poster</p>
                        </div>
                    </div>
                </div>
                
                <div class="panel fade-in">
                    <h2>Cast & Crew Check</h2>
                    <div class="validation-list" id="validationList">
                        <div class="validation-placeholder">
                            <img src="https://www.themoviedb.org/assets/2/v4/logos/v2/blue_square_1-5bdc75aaebeb75dc7ae79426ddd9be3b2be1e342510f8202baf6bffa71d7f5c4.svg" alt="TMDB" class="tmdb-logo">
                            <p>Generate XML first, then validate</p>
                            <button class="validation-btn-main" id="validateBtn" onclick="validateFromXML()" disabled>
                                Validate Cast & Crew
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="outputSection" class="output-container hidden">
            <div class="backdrop-image" id="xmlBackdrop"></div>
            <div class="output-content">
                <div class="output-header">
                    <div class="output-title-row">
                        <h2>Generated iTunes XML</h2>
                        <button class="btn-tmdb-validate" onclick="scrollToValidation()">
                            <img src="https://www.themoviedb.org/assets/2/v4/logos/v2/blue_short-8e7b30f73a4020692ccca9c88bafe5dcb6f8a62a4c6bc55cd9ba82bb2cd95f6c.svg" alt="TMDB" class="tmdb-logo" />
                            Validate
                        </button>
                    </div>
                    <div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">
                        <div class="schema-toggle">
                            <span class="schema-label">5.2</span>
                            <div class="toggle-switch active" id="schemaToggle" onclick="toggleSchema()">
                                <div class="toggle-slider"></div>
                            </div>
                            <span class="schema-label">5.3</span>
                        </div>
                        <div class="mode-toggle">
                            <span class="mode-label active" id="previewLabel">Preview</span>
                            <div class="toggle-switch" id="editToggle" onclick="toggleEditMode()">
                                <div class="toggle-slider"></div>
                            </div>
                            <span class="mode-label" id="editLabel">Edit</span>
                        </div>
                        <button class="btn-primary" onclick="downloadXML()">üíæ Download XML</button>
                    </div>
                </div>
                <div class="xml-output-wrapper">
                    <pre id="xmlOutput"></pre>
                    <textarea id="xmlEditor" class="xml-editor hidden" spellcheck="false"></textarea>
                </div>
            </div>
        </div>
    </div>

    <script>
        let excelData = [];
        let headers = [];
        let currentMappings = {};
        let generatedXML = '';
        let processedMovies = [];
        let currentFileName = '';
        let schemaVersion = '5.3'; // Default to 5.3
        let currentBackdropPath = ''; // Store current movie backdrop

        // TMDB API configuration
        // TMDB API proxy function - calls Netlify serverless function
        // API key is stored securely in Netlify environment variables
        async function tmdbFetch(endpoint, params = '') {
            const response = await fetch('/.netlify/functions/tmdb', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ endpoint, params })
            });
            if (!response.ok) {
                throw new Error(`TMDB API error: ${response.status}`);
            }
            return response.json();
        }
        const TMDB_IMAGE_BASE = 'https://image.tmdb.org/t/p/w500';
        const TMDB_BACKDROP_BASE = 'https://image.tmdb.org/t/p/w1280';

        // Set movie backdrop on XML output section
        function setXmlBackdrop(backdropPath) {
            const backdropEl = document.getElementById('xmlBackdrop');
            if (backdropEl && backdropPath) {
                const backdropUrl = `${TMDB_BACKDROP_BASE}${backdropPath}`;
                backdropEl.style.backgroundImage = `url('${backdropUrl}')`;
                currentBackdropPath = backdropPath;
            } else if (backdropEl) {
                backdropEl.style.backgroundImage = '';
                currentBackdropPath = '';
            }
        }

        // Fetch movie poster from TMDB
        async function fetchMoviePoster(movieTitle, releaseYear = null) {
            const posterContainer = document.getElementById('posterContainer');
            
            // Show loading state
            posterContainer.innerHTML = `
                <div class="poster-loading">
                    <div class="spinner"></div>
                    <p>Searching for poster...</p>
                </div>
            `;
            
            try {
                // Clean the title for search
                let searchTitle = movieTitle.trim();
                
                // Build search params
                let searchParams = `query=${encodeURIComponent(searchTitle)}&language=fr-FR`;
                
                if (releaseYear) {
                    searchParams += `&year=${releaseYear}`;
                }
                
                const data = await tmdbFetch('search/movie', searchParams);
                
                if (data.results && data.results.length > 0) {
                    // Find best match (first result or match by year)
                    let movie = data.results[0];
                    
                    if (releaseYear && data.results.length > 1) {
                        const exactMatch = data.results.find(m => {
                            const movieYear = m.release_date ? m.release_date.substring(0, 4) : '';
                            return movieYear === String(releaseYear);
                        });
                        if (exactMatch) movie = exactMatch;
                    }
                    
                    if (movie.poster_path) {
                        const posterUrl = `${TMDB_IMAGE_BASE}${movie.poster_path}`;
                        const movieYear = movie.release_date ? movie.release_date.substring(0, 4) : '';
                        const tmdbUrl = `https://www.themoviedb.org/movie/${movie.id}`;
                        
                        // Set backdrop for XML output
                        setXmlBackdrop(movie.backdrop_path);
                        
                        posterContainer.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center;">
                                <a href="${tmdbUrl}" target="_blank" rel="noopener noreferrer" class="poster-link">
                                    <img src="${posterUrl}" alt="${movie.title}" class="poster-image" />
                                </a>
                                <div class="movie-info">
                                    <div class="movie-title">${movie.title}</div>
                                    ${movieYear ? `<div class="movie-year">${movieYear}</div>` : ''}
                                </div>
                            </div>
                        `;
                    } else {
                        showPosterNotFound(movieTitle);
                    }
                } else {
                    // Try English search as fallback
                    const fallbackData = await tmdbFetch('search/movie', `query=${encodeURIComponent(searchTitle)}&language=en-US`);
                    
                    if (fallbackData.results && fallbackData.results.length > 0 && fallbackData.results[0].poster_path) {
                        const movie = fallbackData.results[0];
                        const posterUrl = `${TMDB_IMAGE_BASE}${movie.poster_path}`;
                        const movieYear = movie.release_date ? movie.release_date.substring(0, 4) : '';
                        const tmdbUrl = `https://www.themoviedb.org/movie/${movie.id}`;
                        
                        // Set backdrop for XML output
                        setXmlBackdrop(movie.backdrop_path);
                        
                        posterContainer.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center;">
                                <a href="${tmdbUrl}" target="_blank" rel="noopener noreferrer" class="poster-link">
                                    <img src="${posterUrl}" alt="${movie.title}" class="poster-image" />
                                </a>
                                <div class="movie-info">
                                    <div class="movie-title">${movie.title}</div>
                                    ${movieYear ? `<div class="movie-year">${movieYear}</div>` : ''}
                                </div>
                            </div>
                        `;
                    } else {
                        showPosterNotFound(movieTitle);
                    }
                }
            } catch (error) {
                console.error('Error fetching poster:', error);
                posterContainer.innerHTML = `
                    <div class="poster-error">
                        <span class="error-icon">‚ö†Ô∏è</span>
                        <p>Error loading poster</p>
                        <p style="font-size: 0.8rem; margin-top: 5px;">${error.message}</p>
                    </div>
                `;
            }
        }

        function showPosterNotFound(movieTitle) {
            const posterContainer = document.getElementById('posterContainer');
            posterContainer.innerHTML = `
                <div class="poster-error">
                    <span class="error-icon">üé¨</span>
                    <p>No poster found</p>
                    <p style="font-size: 0.85rem; margin-top: 5px; color: var(--accent-yellow);">${movieTitle}</p>
                </div>
            `;
        }

        // Complete Language codes dictionary from RFC5646
        const LANGUAGE_CODES = {
            'af': 'Afrikaans',
            'af-ZA': 'Afrikaans (South Africa)',
            'ar': 'Arabic',
            'ar-AE': 'Arabic (U.A.E.)',
            'ar-BH': 'Arabic (Bahrain)',
            'ar-DZ': 'Arabic (Algeria)',
            'ar-EG': 'Arabic (Egypt)',
            'ar-IQ': 'Arabic (Iraq)',
            'ar-JO': 'Arabic (Jordan)',
            'ar-KW': 'Arabic (Kuwait)',
            'ar-LB': 'Arabic (Lebanon)',
            'ar-LY': 'Arabic (Libya)',
            'ar-MA': 'Arabic (Morocco)',
            'ar-OM': 'Arabic (Oman)',
            'ar-QA': 'Arabic (Qatar)',
            'ar-SA': 'Arabic (Saudi Arabia)',
            'ar-SY': 'Arabic (Syria)',
            'ar-TN': 'Arabic (Tunisia)',
            'ar-YE': 'Arabic (Yemen)',
            'az': 'Azeri (Latin)',
            'az-AZ': 'Azeri (Latin) (Azerbaijan)',
            'az-Cyrl-AZ': 'Azeri (Cyrillic) (Azerbaijan)',
            'be': 'Belarusian',
            'be-BY': 'Belarusian (Belarus)',
            'bg': 'Bulgarian',
            'bg-BG': 'Bulgarian (Bulgaria)',
            'bs-BA': 'Bosnian (Bosnia and Herzegovina)',
            'ca': 'Catalan',
            'ca-ES': 'Catalan (Spain)',
            'cs': 'Czech',
            'cs-CZ': 'Czech (Czech Republic)',
            'cy': 'Welsh',
            'cy-GB': 'Welsh (United Kingdom)',
            'da': 'Danish',
            'da-DK': 'Danish (Denmark)',
            'de': 'German',
            'de-AT': 'German (Austria)',
            'de-CH': 'German (Switzerland)',
            'de-DE': 'German (Germany)',
            'de-LI': 'German (Liechtenstein)',
            'de-LU': 'German (Luxembourg)',
            'dv': 'Divehi',
            'dv-MV': 'Divehi (Maldives)',
            'el': 'Greek',
            'el-GR': 'Greek (Greece)',
            'en': 'English',
            'en-AU': 'English (Australia)',
            'en-BZ': 'English (Belize)',
            'en-CA': 'English (Canada)',
            'en-CB': 'English (Caribbean)',
            'en-GB': 'English (United Kingdom)',
            'en-IE': 'English (Ireland)',
            'en-JM': 'English (Jamaica)',
            'en-NZ': 'English (New Zealand)',
            'en-PH': 'English (Republic of the Philippines)',
            'en-TT': 'English (Trinidad and Tobago)',
            'en-US': 'English (United States)',
            'en-ZA': 'English (South Africa)',
            'en-ZW': 'English (Zimbabwe)',
            'eo': 'Esperanto',
            'es': 'Spanish',
            'es-AR': 'Spanish (Argentina)',
            'es-BO': 'Spanish (Bolivia)',
            'es-CL': 'Spanish (Chile)',
            'es-CO': 'Spanish (Colombia)',
            'es-CR': 'Spanish (Costa Rica)',
            'es-DO': 'Spanish (Dominican Republic)',
            'es-EC': 'Spanish (Ecuador)',
            'es-ES': 'Spanish (Spain)',
            'es-GT': 'Spanish (Guatemala)',
            'es-HN': 'Spanish (Honduras)',
            'es-MX': 'Spanish (Mexico)',
            'es-NI': 'Spanish (Nicaragua)',
            'es-PA': 'Spanish (Panama)',
            'es-PE': 'Spanish (Peru)',
            'es-PR': 'Spanish (Puerto Rico)',
            'es-PY': 'Spanish (Paraguay)',
            'es-SV': 'Spanish (El Salvador)',
            'es-UY': 'Spanish (Uruguay)',
            'es-VE': 'Spanish (Venezuela)',
            'et': 'Estonian',
            'et-EE': 'Estonian (Estonia)',
            'eu': 'Basque',
            'eu-ES': 'Basque (Spain)',
            'fa': 'Farsi',
            'fa-IR': 'Farsi (Iran)',
            'fi': 'Finnish',
            'fi-FI': 'Finnish (Finland)',
            'fo': 'Faroese',
            'fo-FO': 'Faroese (Faroe Islands)',
            'fr': 'French',
            'fr-BE': 'French (Belgium)',
            'fr-CA': 'French (Canada)',
            'fr-CH': 'French (Switzerland)',
            'fr-FR': 'French (France)',
            'fr-LU': 'French (Luxembourg)',
            'fr-MC': 'French (Principality of Monaco)',
            'gl': 'Galician',
            'gl-ES': 'Galician (Spain)',
            'gu': 'Gujarati',
            'gu-IN': 'Gujarati (India)',
            'he': 'Hebrew',
            'he-IL': 'Hebrew (Israel)',
            'hi': 'Hindi',
            'hi-IN': 'Hindi (India)',
            'hr': 'Croatian',
            'hr-BA': 'Croatian (Bosnia and Herzegovina)',
            'hr-HR': 'Croatian (Croatia)',
            'hu': 'Hungarian',
            'hu-HU': 'Hungarian (Hungary)',
            'hy': 'Armenian',
            'hy-AM': 'Armenian (Armenia)',
            'id': 'Indonesian',
            'id-ID': 'Indonesian (Indonesia)',
            'is': 'Icelandic',
            'is-IS': 'Icelandic (Iceland)',
            'it': 'Italian',
            'it-CH': 'Italian (Switzerland)',
            'it-IT': 'Italian (Italy)',
            'ja': 'Japanese',
            'ja-JP': 'Japanese (Japan)',
            'ka': 'Georgian',
            'ka-GE': 'Georgian (Georgia)',
            'kk': 'Kazakh',
            'kk-KZ': 'Kazakh (Kazakhstan)',
            'kn': 'Kannada',
            'kn-IN': 'Kannada (India)',
            'ko': 'Korean',
            'ko-KR': 'Korean (Korea)',
            'kok': 'Konkani',
            'kok-IN': 'Konkani (India)',
            'ky': 'Kyrgyz',
            'ky-KG': 'Kyrgyz (Kyrgyzstan)',
            'lt': 'Lithuanian',
            'lt-LT': 'Lithuanian (Lithuania)',
            'lv': 'Latvian',
            'lv-LV': 'Latvian (Latvia)',
            'mi': 'Maori',
            'mi-NZ': 'Maori (New Zealand)',
            'mk': 'FYRO Macedonian',
            'mk-MK': 'FYRO Macedonian (Former Yugoslav Republic of Macedonia)',
            'mn': 'Mongolian',
            'mn-MN': 'Mongolian (Mongolia)',
            'mr': 'Marathi',
            'mr-IN': 'Marathi (India)',
            'ms': 'Malay',
            'ms-BN': 'Malay (Brunei Darussalam)',
            'ms-MY': 'Malay (Malaysia)',
            'mt': 'Maltese',
            'mt-MT': 'Maltese (Malta)',
            'nb': 'Norwegian (Bokm√•l)',
            'nb-NO': 'Norwegian (Bokm√•l) (Norway)',
            'nl': 'Dutch',
            'nl-BE': 'Dutch (Belgium)',
            'nl-NL': 'Dutch (Netherlands)',
            'nn-NO': 'Norwegian (Nynorsk) (Norway)',
            'ns': 'Northern Sotho',
            'ns-ZA': 'Northern Sotho (South Africa)',
            'pa': 'Punjabi',
            'pa-IN': 'Punjabi (India)',
            'pl': 'Polish',
            'pl-PL': 'Polish (Poland)',
            'ps': 'Pashto',
            'ps-AR': 'Pashto (Afghanistan)',
            'pt': 'Portuguese',
            'pt-BR': 'Portuguese (Brazil)',
            'pt-PT': 'Portuguese (Portugal)',
            'qu': 'Quechua',
            'qu-BO': 'Quechua (Bolivia)',
            'qu-EC': 'Quechua (Ecuador)',
            'qu-PE': 'Quechua (Peru)',
            'ro': 'Romanian',
            'ro-RO': 'Romanian (Romania)',
            'ru': 'Russian',
            'ru-RU': 'Russian (Russia)',
            'sa': 'Sanskrit',
            'sa-IN': 'Sanskrit (India)',
            'se': 'Sami',
            'se-FI': 'Sami (Finland)',
            'se-NO': 'Sami (Norway)',
            'se-SE': 'Sami (Sweden)',
            'sk': 'Slovak',
            'sk-SK': 'Slovak (Slovakia)',
            'sl': 'Slovenian',
            'sl-SI': 'Slovenian (Slovenia)',
            'sq': 'Albanian',
            'sq-AL': 'Albanian (Albania)',
            'sr-BA': 'Serbian (Latin) (Bosnia and Herzegovina)',
            'sr-Cyrl-BA': 'Serbian (Cyrillic) (Bosnia and Herzegovina)',
            'sr-SP': 'Serbian (Latin) (Serbia and Montenegro)',
            'sr-Cyrl-SP': 'Serbian (Cyrillic) (Serbia and Montenegro)',
            'sv': 'Swedish',
            'sv-FI': 'Swedish (Finland)',
            'sv-SE': 'Swedish (Sweden)',
            'sw': 'Swahili',
            'sw-KE': 'Swahili (Kenya)',
            'syr': 'Syriac',
            'syr-SY': 'Syriac (Syria)',
            'ta': 'Tamil',
            'ta-IN': 'Tamil (India)',
            'te': 'Telugu',
            'te-IN': 'Telugu (India)',
            'th': 'Thai',
            'th-TH': 'Thai (Thailand)',
            'tl': 'Tagalog',
            'tl-PH': 'Tagalog (Philippines)',
            'tn': 'Tswana',
            'tn-ZA': 'Tswana (South Africa)',
            'tr': 'Turkish',
            'tr-TR': 'Turkish (Turkey)',
            'tt': 'Tatar',
            'tt-RU': 'Tatar (Russia)',
            'ts': 'Tsonga',
            'uk': 'Ukrainian',
            'uk-UA': 'Ukrainian (Ukraine)',
            'ur': 'Urdu',
            'ur-PK': 'Urdu (Islamic Republic of Pakistan)',
            'uz': 'Uzbek (Latin)',
            'uz-UZ': 'Uzbek (Latin) (Uzbekistan)',
            'uz-Cyrl-UZ': 'Uzbek (Cyrillic) (Uzbekistan)',
            'vi': 'Vietnamese',
            'vi-VN': 'Vietnamese (Viet Nam)',
            'xh': 'Xhosa',
            'xh-ZA': 'Xhosa (South Africa)',
            'zh': 'Chinese',
            'zh-CN': 'Chinese (S)',
            'zh-HK': 'Chinese (Hong Kong)',
            'zh-MO': 'Chinese (Macau)',
            'zh-SG': 'Chinese (Singapore)',
            'zh-TW': 'Chinese (T)',
            'zu': 'Zulu',
            'zu-ZA': 'Zulu (South Africa)'
        };

        // Country codes dictionary (ISO 3166)
        const COUNTRY_CODES = {
            'FR': 'France',
            'US': 'United States',
            'GB': 'United Kingdom',
            'DE': 'Germany',
            'ES': 'Spain',
            'IT': 'Italy',
            'PT': 'Portugal',
            'NL': 'Netherlands',
            'BE': 'Belgium',
            'CH': 'Switzerland',
            'CA': 'Canada',
            'AU': 'Australia',
            'JP': 'Japan',
            'CN': 'China',
            'KR': 'Korea'
        };

        // Mapping from simple country/language codes to RFC5646 language tags
        const LOCALE_TO_RFC5646 = {
            'FR': 'fr-FR',
            'fr': 'fr-FR',
            'French': 'fr-FR',
            'US': 'en-US',
            'en': 'en-US',
            'English': 'en-US',
            'GB': 'en-GB',
            'UK': 'en-GB',
            'DE': 'de-DE',
            'de': 'de-DE',
            'German': 'de-DE',
            'ES': 'es-ES',
            'es': 'es-ES',
            'Spanish': 'es-ES',
            'IT': 'it-IT',
            'it': 'it-IT',
            'Italian': 'it-IT',
            'PT': 'pt-PT',
            'pt': 'pt-PT',
            'Portuguese': 'pt-PT',
            'NL': 'nl-NL',
            'nl': 'nl-NL',
            'Dutch': 'nl-NL',
            'BE': 'fr-BE',
            'be': 'fr-BE',
            'CH': 'fr-CH',
            'ch': 'fr-CH',
            'CA': 'fr-CA',
            'ca': 'en-CA',
            'AU': 'en-AU',
            'au': 'en-AU',
            'JP': 'ja-JP',
            'ja': 'ja-JP',
            'Japanese': 'ja-JP',
            'CN': 'zh-CN',
            'zh': 'zh-CN',
            'Chinese': 'zh-CN',
            'KR': 'ko-KR',
            'ko': 'ko-KR',
            'Korean': 'ko-KR',
            'PL': 'pl-PL',
            'pl': 'pl-PL',
            'Polish': 'pl-PL'
        };

        // Enhanced Genre codes from iTunes specification
        const GENRE_CODES = {
            'Action': 'ACTION-ADVENTURE-00',
            'Adventure': 'ACTION-ADVENTURE-00',
            'African': 'AFRICAN-00',
            'Anime': 'ANIME-00',
            'Bollywood': 'BOLLYWOOD-00',
            'Classics': 'CLASSICS-00',
            'Comedy': 'COMEDY-00',
            'Com√©die': 'COMEDY-00',
            'Concert Films': 'CONCERT-FILMS-00',
            'Documentary': 'DOCUMENTARY-00',
            'Drama': 'DRAMA-00',
            'Drame': 'DRAMA-00',
            'Foreign': 'FOREIGN-00',
            'Holiday': 'HOLIDAY-00',
            'Horror': 'HORROR-00',
            'Independent': 'INDEPENDENT-00',
            'Kids': 'KIDS-FAMILY-00',
            'Family': 'KIDS-FAMILY-00',
            'Made for TV': 'MADE-FOR-TV-00',
            'Middle Eastern': 'MIDDLE-EASTERN-00',
            'Music Documentary': 'MUSIC-DOCUMENTARIES-00',
            'Music Feature Film': 'MUSIC-FEATURE-FILMS-00',
            'Musical': 'MUSICALS-00',
            'Musicals': 'MUSICALS-00',
            'Regional Indian': 'REGIONAL-INDIAN-00',
            'Romance': 'ROMANCE-00',
            'Russian': 'RUSSIAN-00',
            'Sci-Fi': 'SCIFI-FANTASY-00',
            'Fantasy': 'SCIFI-FANTASY-00',
            'Short Films': 'SHORT-FILMS-00',
            'Special Interest': 'SPECIAL-INTEREST-00',
            'Sports': 'SPORTS-00',
            'Thriller': 'THRILLER-00',
            'Turkish': 'TURKISH-00',
            'Urban': 'URBAN-00',
            'Western': 'WESTERN-00'
        };

        // Rating codes for France (fr-cnc)
        const RATING_CODES = {
            'Tous Publics': 'TP',
            'TP': 'TP',
            '-10': '-10',
            '-12': '-12',
            '-16': '-16',
            '-18': '-18',
            'UR': 'UR'
        };

        // Columns to ignore in mapping (column indices)
        const IGNORED_COLUMNS = [
            19,  // T
            22,  // W
            26,  // AA
            30,  // AE
            31,  // AF
            36,  // AK
            37,  // AL
            34,  // AI
            38,  // AM
            35   // AJ
        ];

        // XML field definitions with paths and types
        const xmlFields = {
            'provider': { path: 'provider', type: 'text' },
            'language': { path: 'language', type: 'text' },
            'video_type': { path: 'video/type', type: 'text' },
            'video_subtype': { path: 'video/subtype', type: 'text' },
            'vendor_id': { path: 'video/vendor_id', type: 'text' },
            'country': { path: 'video/countries_of_origin/country', type: 'text', attr: 'primary="true"' },
            'production_country': { path: 'video/production_countries/country', type: 'text', attr: 'primary="true"' },
            'original_spoken_locale': { path: 'video/original_spoken_locale', type: 'text' },
            'title': { path: 'video/title', type: 'text' },
            'studio_release_title': { path: 'video/studio_release_title', type: 'text' },
            'synopsis': { path: 'video/synopsis', type: 'text' },
            'production_company': { path: 'video/production_company', type: 'text' },
            'copyright': { path: 'video/copyright_cline', type: 'text' },
            'theatrical_release': { path: 'video/theatrical_release_date', type: 'date' },
            'genre': { path: 'video/genres/genre', type: 'genre' },
            'rating': { path: 'video/ratings/rating', type: 'rating' },
            'cast': { path: 'video/cast', type: 'cast' },
            'crew': { path: 'video/crew', type: 'crew' },
            'territory': { path: 'video/products/product/territory', type: 'text' },
            'cleared_sale': { path: 'video/products/product/cleared_for_sale', type: 'boolean' },
            'cleared_hd_sale': { path: 'video/products/product/cleared_for_hd_sale', type: 'boolean' },
            'sales_start': { path: 'video/products/product/sales_start_date', type: 'date' },
            'sales_end': { path: 'video/products/product/sales_end_date', type: 'date' },
            'cleared_vod': { path: 'video/products/product/cleared_for_vod', type: 'boolean' },
            'vod_start': { path: 'video/products/product/available_for_vod_date', type: 'date' },
            'vod_end': { path: 'video/products/product/unavailable_for_vod_date', type: 'date' },
            'cleared_hd_vod': { path: 'video/products/product/cleared_for_hd_vod', type: 'boolean' },
            'physical_release': { path: 'video/products/product/physical_release_date', type: 'date' },
            'preorder_date': { path: 'video/products/product/preorder_sales_start_date', type: 'date' }
        };

        // Fixed mappings based on column positions
        const fixedMappings = {
            'vendor_id': 4,  // Column E
            'production_company': 10,  // Column K
            'preorder_date': 33  // Column AH (Pre Order Date)
        };

        // Auto-mapping rules for other fields
        const autoMappingRules = {
            'language': 'language',
            'provider': 'provider',
            'video_type': 'video_type',
            'video_subtype': 'video_subtype',
            'country': 'country',
            'Original_Spoken_Locale': 'original_spoken_locale',
            'title': 'title',
            'original title': 'studio_release_title',
            'synopsis': 'synopsis',
            'copyright_cline': 'copyright',
            'theatrical_release_date': 'theatrical_release',
            'genre': 'genre',
            'rating': 'rating',
            'cast': 'cast',
            'crew': 'crew',
            'territory': 'territory',
            'cleared for sale': 'cleared_sale',
            'Sales stard date': 'sales_start',
            'Sales end date': 'sales_end',
            'cleared for vod': 'cleared_vod',
            'available for vod date': 'vod_start',
            'unavailable for vod date': 'vod_end',
            'cleared for hd vod': 'cleared_hd_vod',
            'France physical release date': 'physical_release'
        };

        // Toggle schema version
        function toggleSchema() {
            const toggle = document.getElementById('schemaToggle');
            toggle.classList.toggle('active');
            schemaVersion = toggle.classList.contains('active') ? '5.3' : '5.2';
            
            // Regenerate XML if it exists
            if (generatedXML) {
                generateXML();
            }
        }

        let isEditMode = false;

        function toggleEditMode() {
            const toggle = document.getElementById('editToggle');
            const previewLabel = document.getElementById('previewLabel');
            const editLabel = document.getElementById('editLabel');
            const xmlOutput = document.getElementById('xmlOutput');
            const xmlEditor = document.getElementById('xmlEditor');
            const wrapper = document.querySelector('.xml-output-wrapper');
            
            toggle.classList.toggle('active');
            isEditMode = toggle.classList.contains('active');
            
            // Update labels
            previewLabel.classList.toggle('active', !isEditMode);
            editLabel.classList.toggle('active', isEditMode);
            
            if (isEditMode) {
                // Switch to edit mode
                wrapper.classList.add('edit-mode');
                xmlEditor.value = generatedXML;
                xmlEditor.classList.remove('hidden');
                
                // Sync height and set cursor at the beginning
                syncEditorHeight();
                xmlEditor.focus();
                xmlEditor.setSelectionRange(0, 0);
                xmlEditor.scrollTop = 0;
                xmlOutput.scrollTop = 0;
            } else {
                // Switch to preview mode - update generatedXML with edited content
                wrapper.classList.remove('edit-mode');
                generatedXML = xmlEditor.value;
                xmlOutput.innerHTML = highlightXML(generatedXML);
                xmlEditor.classList.add('hidden');
            }
        }

        // Sync textarea scroll and content with highlighted pre
        function setupEditorSync() {
            const xmlEditor = document.getElementById('xmlEditor');
            const xmlOutput = document.getElementById('xmlOutput');
            
            // Sync scrolling
            xmlEditor.addEventListener('scroll', function() {
                xmlOutput.scrollTop = xmlEditor.scrollTop;
                xmlOutput.scrollLeft = xmlEditor.scrollLeft;
            });
            
            // Sync content on input (update highlighting in real-time)
            xmlEditor.addEventListener('input', function() {
                generatedXML = xmlEditor.value;
                xmlOutput.innerHTML = highlightXML(generatedXML);
                syncEditorHeight();
            });
        }
        
        // Sync editor height with content
        function syncEditorHeight() {
            // Heights are managed by CSS max-height, just ensure proper scrolling
            const xmlEditor = document.getElementById('xmlEditor');
            const xmlOutput = document.getElementById('xmlOutput');
            
            if (xmlOutput && xmlEditor) {
                // Sync scroll position
                xmlOutput.scrollTop = 0;
                xmlEditor.scrollTop = 0;
            }
        }

        // Initialize editor sync when DOM is ready
        document.addEventListener('DOMContentLoaded', setupEditorSync);

        // Function to convert locale to RFC5646 format
        function toRFC5646Locale(locale) {
            if (!locale) return '';
            
            // Check if it's already in RFC5646 format (contains a hyphen)
            if (locale.includes('-')) {
                return locale;
            }
            
            // Try to find mapping
            const mapped = LOCALE_TO_RFC5646[locale] || LOCALE_TO_RFC5646[locale.toLowerCase()];
            if (mapped) {
                return mapped;
            }
            
            // If no mapping found, try to construct one if it looks like a 2-letter code
            if (locale.length === 2) {
                const lower = locale.toLowerCase();
                // Default to the most common country for that language
                switch(lower) {
                    case 'fr': return 'fr-FR';
                    case 'en': return 'en-US';
                    case 'de': return 'de-DE';
                    case 'es': return 'es-ES';
                    case 'it': return 'it-IT';
                    case 'pt': return 'pt-PT';
                    case 'nl': return 'nl-NL';
                    case 'pl': return 'pl-PL';
                    case 'ru': return 'ru-RU';
                    case 'ja': return 'ja-JP';
                    case 'ko': return 'ko-KR';
                    case 'zh': return 'zh-CN';
                    default: return locale; // Return as-is if unknown
                }
            }
            
            return locale; // Return as-is if no conversion possible
        }

        // Function to convert text to proper title case
        function toTitleCase(str) {
            if (!str) return '';
            return str.replace(/\w\S*/g, function(txt){
                return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
            });
        }

        // Function to convert French titles (only first letter uppercase)
        // "LA BONNE √âTOILE" ‚Üí "La bonne √©toile"
        function toFrenchTitleCase(str) {
            if (!str) return '';
            
            // Convert entire string to lowercase first (handles accented chars)
            let lower = str.toLowerCase();
            
            // Capitalize only the first letter
            return lower.charAt(0).toUpperCase() + lower.slice(1);
        }

        // Function to convert text to proper name case (handles names better)
        function toProperCase(str) {
            if (!str) return '';
            
            // Preserve accented characters and handle word boundaries better
            return str.split(/\s+/).map(word => {
                // Handle hyphenated names
                if (word.includes('-')) {
                    return word.split('-').map(part => 
                        part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
                    ).join('-');
                }
                // Handle apostrophes (D'Angelo, O'Brien, etc.)
                if (word.includes("'")) {
                    return word.split("'").map(part => 
                        part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
                    ).join("'");
                }
                // Regular word
                return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
            }).join(' ');
        }

        // Translate character role terms from English to French
        function translateCharacterRole(character) {
            if (!character) return '';
            
            // Translation map for common role descriptors
            const translations = {
                '(voice)': '(voix)',
                '(Voice)': '(voix)',
                '(VOICE)': '(voix)',
                ' voice)': ' voix)',
                '(uncredited)': '(non cr√©dit√©)',
                '(Uncredited)': '(non cr√©dit√©)',
                '(archive footage)': '(images d\'archives)',
                '(Archive footage)': '(images d\'archives)',
                '(cameo)': '(cam√©o)',
                '(Cameo)': '(cam√©o)'
            };
            
            let translated = character;
            for (const [eng, fr] of Object.entries(translations)) {
                translated = translated.replace(new RegExp(eng.replace(/[()]/g, '\\$&'), 'gi'), fr);
            }
            
            return translated;
        }

        // Setup drag and drop
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        function handleFile(file) {
            // Reset validation list and XML output when new file is loaded
            document.getElementById('validationList').innerHTML = `
                <div class="validation-placeholder">
                    <span class="validation-icon">üîç</span>
                    <p>Select a movie to validate cast & crew</p>
                </div>
            `;
            document.getElementById('xmlOutput').innerHTML = '';
            document.getElementById('outputSection').classList.add('hidden');
            generatedXML = '';
            currentMappings = {};
            
            currentFileName = file.name;
            document.getElementById('currentFileName').textContent = currentFileName;
            document.getElementById('fileInfo').classList.remove('hidden');
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                
                if (jsonData.length > 0) {
                    headers = jsonData[0];
                    excelData = jsonData.slice(1);
                    
                    // Process movies from rows 2-6 (index 1-5 in excelData)
                    processMoviesFromData();
                    
                    populateRowSelector();
                    displayMappings();
                    document.getElementById('mappingSection').classList.remove('hidden');
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function processMoviesFromData() {
            processedMovies = [];
            
            // Look for main data rows (typically row 3, index 2)
            // Check rows 2-6 for actual movie data
            for (let i = 1; i <= 5 && i < excelData.length; i++) {
                const row = excelData[i];
                // Check if this row has a title (column H, index 7)
                if (row && row[7]) {
                    // This is a main movie row
                    const movie = {
                        mainRowIndex: i,
                        title: row[7],
                        data: row,
                        crew: [],
                        castFromRows: [] // Cast collected from separate rows (P/Q pattern)
                    };
                    
                    // IMPORTANT: Check if the main row has a director
                    if (row[17] && row[18]) { // Column R and S
                        movie.crew.push({
                            role: row[17],
                            names: row[18]
                        });
                    }
                    
                    // Check if main row has cast in separate column format (P = actor, Q = role)
                    if (row[15] && row[16] && String(row[16]).includes('R√¥le')) {
                        const role = String(row[16]).replace(/^R√¥le\s*:\s*/i, '').trim();
                        movie.castFromRows.push({
                            actor: row[15],
                            character: role
                        });
                    }
                    
                    // Collect crew and cast from subsequent rows
                    for (let j = i + 1; j <= i + 20 && j < excelData.length; j++) {
                        const subRow = excelData[j];
                        if (!subRow) continue;
                        
                        // Stop if we hit another movie (has title in column H)
                        if (subRow[7] && j > i) break;
                        
                        // Collect crew from Column R and S
                        if (subRow[17] && subRow[18]) {
                            movie.crew.push({
                                role: subRow[17],
                                names: subRow[18]
                            });
                        }
                        
                        // Collect cast from Column P and Q (actor + "R√¥le : Character" pattern)
                        if (subRow[15] && subRow[16] && String(subRow[16]).includes('R√¥le')) {
                            const role = String(subRow[16]).replace(/^R√¥le\s*:\s*/i, '').trim();
                            movie.castFromRows.push({
                                actor: subRow[15],
                                character: role
                            });
                        }
                    }
                    
                    processedMovies.push(movie);
                }
            }
        }

        function populateRowSelector() {
            const select = document.getElementById('rowSelect');
            select.innerHTML = '';
            
            processedMovies.forEach((movie, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = movie.title;
                select.appendChild(option);
            });
            
            select.addEventListener('change', updateDataPreview);
        }

        function displayMappings() {
            // Mapping list UI has been replaced by poster panel
            // But we still need to set up the mappings internally
            
            headers.forEach((header, index) => {
                if (!header) return;
                
                // Skip ignored columns
                if (IGNORED_COLUMNS.includes(index)) return;
                
                // Check if this is a fixed mapping
                const fixedField = Object.keys(fixedMappings).find(key => fixedMappings[key] === index);
                if (fixedField) {
                    currentMappings[index] = fixedField;
                }
            });
            
            // Auto-apply fixed mappings and auto-map
            autoMapFixed();
            autoMap();
            updateDataPreview();
        }

        function autoMapFixed() {
            // Apply fixed mappings (no UI elements)
            Object.entries(fixedMappings).forEach(([xmlField, colIndex]) => {
                currentMappings[colIndex] = xmlField;
            });
        }

        function autoMap() {
            // First apply fixed mappings
            autoMapFixed();
            
            // Then apply auto-mapping rules based on header names
            headers.forEach((header, index) => {
                if (!header) return;
                if (IGNORED_COLUMNS.includes(index)) return;
                
                // Skip if already mapped by fixed mapping
                if (currentMappings[index]) {
                    return;
                }
                
                if (autoMappingRules[header]) {
                    currentMappings[index] = autoMappingRules[header];
                }
            });
            
            updateDataPreview();
        }

        function resetMappings() {
            currentMappings = {};
            // Clear previews
            document.getElementById('validationList').innerHTML = `
                <div class="validation-placeholder">
                    <span class="validation-icon">üîç</span>
                    <p>Select a movie to validate cast & crew</p>
                </div>
            `;
            document.getElementById('xmlOutput').innerHTML = '';
            document.getElementById('outputSection').classList.add('hidden');
            generatedXML = '';
            
            // Reset poster
            const posterContainer = document.getElementById('posterContainer');
            if (posterContainer) {
                posterContainer.innerHTML = `
                    <div class="poster-placeholder">
                        <span class="poster-icon">üé¨</span>
                        <p>Select a movie to display poster</p>
                    </div>
                `;
            }
            
            // Re-apply mappings
            autoMap();
        }

        function resetAll() {
            location.reload();
        }

        function formatDate(dateValue) {
            if (!dateValue) return '';
            
            // Handle Excel date serial number or date string
            let date;
            if (typeof dateValue === 'number') {
                // Excel date serial number
                date = new Date((dateValue - 25569) * 86400 * 1000);
            } else if (typeof dateValue === 'string') {
                // Handle ISO string or other date formats
                if (dateValue.includes('T')) {
                    date = new Date(dateValue);
                } else {
                    date = new Date(dateValue);
                }
            } else {
                date = dateValue;
            }
            
            // Format as YYYY-MM-DD
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            
            return `${year}-${month}-${day}`;
        }

        function updateDataPreview() {
            const movieIndex = document.getElementById('rowSelect').value;
            const validationList = document.getElementById('validationList');
            
            // Reset validation zone
            const isXmlGenerated = generatedXML && generatedXML.length > 0;
            validationList.innerHTML = `
                <div class="validation-placeholder">
                    <img src="https://www.themoviedb.org/assets/2/v4/logos/v2/blue_square_1-5bdc75aaebeb75dc7ae79426ddd9be3b2be1e342510f8202baf6bffa71d7f5c4.svg" alt="TMDB" class="tmdb-logo">
                    <p>${isXmlGenerated ? 'Click to validate against TMDB' : 'Generate XML first, then validate'}</p>
                    <button class="validation-btn-main" id="validateBtn" onclick="validateFromXML()" ${isXmlGenerated ? '' : 'disabled'}>
                        Validate Cast & Crew
                    </button>
                </div>
            `;
            
            if (!processedMovies[movieIndex]) {
                return;
            }
            
            const movie = processedMovies[movieIndex];
            const row = movie.data;
            
            // Fetch movie poster from TMDB
            let releaseYear = null;
            const theatricalDate = row[12];
            if (theatricalDate) {
                const formattedDate = formatDate(theatricalDate);
                if (formattedDate) {
                    releaseYear = formattedDate.substring(0, 4);
                }
            }
            
            if (movie.title) {
                fetchMoviePoster(movie.title, releaseYear);
            }
        }

        // Scroll to validation section and trigger validation
        function scrollToValidation() {
            const validationPanel = document.getElementById('validationList').closest('.panel');
            if (validationPanel) {
                validationPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Trigger validation after a short delay
                setTimeout(() => {
                    validateFromXML();
                }, 300);
            }
        }

        // Validate cast and crew from generated XML against TMDB
        async function validateFromXML() {
            if (!generatedXML) {
                alert('Please generate XML first');
                return;
            }
            
            const validationList = document.getElementById('validationList');
            const movieIndex = document.getElementById('rowSelect').value;
            const movie = processedMovies[movieIndex];
            
            if (!movie) return;
            
            // Show loading state
            validationList.innerHTML = `
                <div class="validation-loading">
                    <div class="spinner"></div>
                    <p>Validating cast & crew...</p>
                </div>
            `;
            
            try {
                // Extract cast and crew names from the generated XML
                const castNames = extractNamesFromXML(generatedXML, 'cast_member');
                const crewNames = extractNamesFromXML(generatedXML, 'crew_member');
                
                // Get movie info for TMDB search
                const row = movie.data;
                let releaseYear = null;
                const theatricalDate = row[12];
                if (theatricalDate) {
                    const formattedDate = formatDate(theatricalDate);
                    if (formattedDate) {
                        releaseYear = formattedDate.substring(0, 4);
                    }
                }
                
                // Search for the movie on TMDB
                let searchParams = `query=${encodeURIComponent(movie.title)}&language=fr-FR`;
                if (releaseYear) {
                    searchParams += `&year=${releaseYear}`;
                }
                
                let searchData = await tmdbFetch('search/movie', searchParams);
                
                if (!searchData.results || searchData.results.length === 0) {
                    // Try English search
                    const fallbackData = await tmdbFetch('search/movie', `query=${encodeURIComponent(movie.title)}&language=en-US`);
                    
                    if (!fallbackData.results || fallbackData.results.length === 0) {
                        validationList.innerHTML = `
                            <div class="validation-placeholder">
                                <span class="validation-icon">‚ùì</span>
                                <p>Movie not found on TMDB</p>
                            </div>
                        `;
                        return;
                    }
                    searchData.results = fallbackData.results;
                }
                
                // Get the movie ID
                const tmdbMovie = searchData.results[0];
                const movieId = tmdbMovie.id;
                
                // Set backdrop for XML output
                if (tmdbMovie.backdrop_path) {
                    setXmlBackdrop(tmdbMovie.backdrop_path);
                }
                
                // Fetch credits (cast and crew)
                const creditsData = await tmdbFetch(`movie/${movieId}/credits`, 'language=fr-FR');
                
                // Extract TMDB cast and crew (including character/job info)
                const tmdbCastFull = (creditsData.cast || []).map(c => ({
                    id: c.id,
                    name: c.name,
                    normalized: normalizeName(c.name),
                    character: c.character || ''
                }));
                const tmdbCastOriginal = tmdbCastFull.map(c => c.name);
                const tmdbCastNormalized = tmdbCastFull.map(c => c.normalized);
                const tmdbCastIds = tmdbCastFull.map(c => c.id);
                
                const tmdbCrewFull = (creditsData.crew || []).map(c => ({
                    id: c.id,
                    name: c.name,
                    normalized: normalizeName(c.name),
                    job: c.job || '',
                    department: c.department || ''
                }));
                const tmdbCrewOriginal = tmdbCrewFull.map(c => c.name);
                const tmdbCrewNormalized = tmdbCrewFull.map(c => c.normalized);
                const tmdbCrewIds = tmdbCrewFull.map(c => c.id);
                
                // Build validation HTML
                let html = '';
                
                // Cast validation
                if (castNames.length > 0) {
                    html += `<div class="validation-section">`;
                    html += `<div class="validation-section-title">Cast (${castNames.length})</div>`;
                    
                    for (let index = 0; index < castNames.length; index++) {
                        const item = castNames[index];
                        const name = item.name;
                        const character = item.roles;
                        const normalizedName = normalizeName(name);
                        let match = findBestMatch(normalizedName, tmdbCastNormalized, tmdbCastOriginal);
                        
                        // Get TMDB character if we have a match
                        const tmdbCharacter = (match.index >= 0 && tmdbCastFull[match.index]) ? tmdbCastFull[match.index].character : '';
                        const tmdbCharacterDisplay = translateCharacterRole(tmdbCharacter);
                        
                        const charHtml = character ? `<span class="role-tag">${character}</span>` : '';
                        
                        // Check if character names differ (with some tolerance for variations)
                        const hasCharacterDiff = character && tmdbCharacter && 
                            !areCharactersEquivalent(character, tmdbCharacter);
                        
                        if (match.score >= 0.85) {
                            const hasAccentIssue = hasAccentDifference(name, match.original);
                            
                            if (hasAccentIssue && hasCharacterDiff) {
                                // Both name and role need fixing
                                html += `
                                    <div class="validation-item accent-warning">
                                        <span class="validation-status">‚óê</span>
                                        <div class="validation-name">
                                            <div class="excel-name">${name} ${charHtml}</div>
                                            <div class="tmdb-name">TMDB: ${match.original} <span class="tmdb-role-diff">(${tmdbCharacterDisplay})</span></div>
                                        </div>
                                        <div class="validation-action validation-action-multi">
                                            <button class="validation-btn fix" onclick="fixName('cast', ${index}, '${escapeQuotes(name)}', '${escapeQuotes(match.original)}', this)">Fix Name</button>
                                            <button class="validation-btn fix-role" onclick="fixRole('cast', '${escapeQuotes(name)}', '${escapeQuotes(character)}', '${escapeQuotes(tmdbCharacterDisplay)}', this)">Fix Role</button>
                                        </div>
                                    </div>
                                `;
                            } else if (hasAccentIssue) {
                                // Only name needs fixing
                                html += `
                                    <div class="validation-item accent-warning">
                                        <span class="validation-status">‚óê</span>
                                        <div class="validation-name">
                                            <div class="excel-name">${name} ${charHtml}</div>
                                            <div class="tmdb-name">TMDB: ${match.original}${tmdbCharacter ? ` <span class="tmdb-role">(${tmdbCharacterDisplay})</span>` : ''}</div>
                                        </div>
                                        <div class="validation-action">
                                            <button class="validation-btn fix" onclick="fixName('cast', ${index}, '${escapeQuotes(name)}', '${escapeQuotes(match.original)}', this)">Fix Name</button>
                                        </div>
                                    </div>
                                `;
                            } else if (hasCharacterDiff) {
                                // Only role needs fixing
                                html += `
                                    <div class="validation-item role-warning">
                                        <span class="validation-status"><span class="status-ok">‚úì</span></span>
                                        <div class="validation-name">
                                            <div class="excel-name">${name} ${charHtml}</div>
                                            <div class="tmdb-match">‚Ü≥ ${match.original} <span class="tmdb-role-diff">(TMDB: ${tmdbCharacterDisplay})</span></div>
                                        </div>
                                        <div class="validation-action">
                                            <button class="validation-btn fix-role" onclick="fixRole('cast', '${escapeQuotes(name)}', '${escapeQuotes(character)}', '${escapeQuotes(tmdbCharacterDisplay)}', this)">Fix Role</button>
                                        </div>
                                    </div>
                                `;
                            } else {
                                // Both name and role are valid
                                html += `
                                    <div class="validation-item valid">
                                        <span class="validation-status"><span class="status-ok">‚úì</span></span>
                                        <div class="validation-name">
                                            <div class="excel-name">${name} ${charHtml}</div>
                                            <div class="tmdb-match">‚Ü≥ ${match.original}${tmdbCharacter ? ` <span class="tmdb-role">(${tmdbCharacterDisplay})</span>` : ''}</div>
                                        </div>
                                    </div>
                                `;
                            }
                        } else if (match.score >= 0.6) {
                            html += `
                                <div class="validation-item invalid">
                                    <span class="validation-status">‚âà</span>
                                    <div class="validation-name">
                                        <div class="excel-name">${name} ${charHtml}</div>
                                        <div class="tmdb-name">Similar: ${match.original || 'N/A'}${tmdbCharacter ? ` <span class="tmdb-role">(${tmdbCharacterDisplay})</span>` : ''}</div>
                                    </div>
                                    <div class="validation-action">
                                        <button class="validation-btn fix" onclick="fixName('cast', ${index}, '${escapeQuotes(name)}', '${escapeQuotes(match.original)}', this)">Fix Name</button>
                                    </div>
                                </div>
                            `;
                        } else {
                            // Try alias search
                            const aliasResult = await searchPersonAlias(name, tmdbCastIds);
                            
                            if (aliasResult.found) {
                                html += `
                                    <div class="validation-item accent-warning">
                                        <span class="validation-status">‚óê</span>
                                        <div class="validation-name">
                                            <div class="excel-name">${name} ${charHtml}</div>
                                            <div class="tmdb-name">TMDB: ${aliasResult.tmdbName}</div>
                                        </div>
                                        <div class="validation-action">
                                            <button class="validation-btn fix" onclick="fixName('cast', ${index}, '${escapeQuotes(name)}', '${escapeQuotes(aliasResult.tmdbName)}', this)">Fix Name</button>
                                        </div>
                                    </div>
                                `;
                            } else {
                                html += `
                                    <div class="validation-item not-found">
                                        <span class="validation-status">‚úó</span>
                                        <div class="validation-name">
                                            <div class="excel-name">${name} ${charHtml}</div>
                                            <div class="tmdb-name">Not found in TMDB</div>
                                        </div>
                                        <div class="validation-action">
                                            <button class="validation-btn delete" onclick="deleteName('cast', ${index}, '${escapeQuotes(name)}', this)">Delete</button>
                                        </div>
                                    </div>
                                `;
                            }
                        }
                    }
                    
                    // Check for missing top cast from TMDB (top 5)
                    const xmlCastNormalized = castNames.map(c => normalizeName(c.name));
                    const missingTopCast = [];
                    const topN = Math.min(5, tmdbCastFull.length);
                    
                    for (let i = 0; i < topN; i++) {
                        const tmdbPerson = tmdbCastFull[i];
                        const tmdbNormalized = tmdbPerson.normalized;
                        
                        // Check if this person is in XML (with fuzzy matching)
                        let found = false;
                        for (const xmlNorm of xmlCastNormalized) {
                            const similarity = stringSimilarity(xmlNorm, tmdbNormalized);
                            if (similarity >= 0.85) {
                                found = true;
                                break;
                            }
                        }
                        
                        if (!found) {
                            missingTopCast.push({
                                name: tmdbPerson.name,
                                character: tmdbPerson.character,
                                order: i + 1
                            });
                        }
                    }
                    
                    // Show missing cast suggestions
                    if (missingTopCast.length > 0) {
                        html += `<div class="validation-subsection">`;
                        html += `<div class="validation-subsection-title">‚ö†Ô∏è Missing from TMDB top 5</div>`;
                        
                        for (const missing of missingTopCast) {
                            html += `
                                <div class="validation-item suggestion">
                                    <span class="validation-status">+</span>
                                    <div class="validation-name">
                                        <div class="excel-name">${missing.name} <span class="role-tag">${translateCharacterRole(missing.character)}</span></div>
                                        <div class="tmdb-name">TMDB #${missing.order}</div>
                                    </div>
                                    <div class="validation-action">
                                        <button class="validation-btn add" onclick="addCastMember('${escapeQuotes(missing.name)}', '${escapeQuotes(translateCharacterRole(missing.character))}', this)">Add</button>
                                    </div>
                                </div>
                            `;
                        }
                        
                        html += `</div>`;
                    }
                    
                    html += `</div>`;
                }
                
                // Crew validation
                if (crewNames.length > 0) {
                    html += `<div class="validation-section">`;
                    html += `<div class="validation-section-title">Crew (${crewNames.length})</div>`;
                    
                    // Track which TMDB crew members have been matched
                    const matchedTmdbCrewNames = new Set();
                    
                    // First pass: identify all valid matches
                    for (const item of crewNames) {
                        const normalizedName = normalizeName(item.name);
                        const match = findBestMatch(normalizedName, tmdbCrewNormalized, tmdbCrewOriginal);
                        if (match.score >= 0.85 && match.original) {
                            matchedTmdbCrewNames.add(match.original.toLowerCase());
                        }
                    }
                    
                    for (let index = 0; index < crewNames.length; index++) {
                        const item = crewNames[index];
                        const name = item.name;
                        const roles = item.roles;
                        const normalizedName = normalizeName(name);
                        let match = findBestMatch(normalizedName, tmdbCrewNormalized, tmdbCrewOriginal);
                        
                        // Get TMDB job info if we have a match
                        const tmdbJob = (match.index >= 0 && tmdbCrewFull[match.index]) ? tmdbCrewFull[match.index].job : '';
                        
                        const roleHtml = roles ? `<span class="role-tag">${roles}</span>` : '';
                        
                        // Check if job/role differs (using equivalence check)
                        const hasRoleDiff = roles && tmdbJob && !areRolesEquivalent(roles, tmdbJob);
                        
                        if (match.score >= 0.85) {
                            const hasAccentIssue = hasAccentDifference(name, match.original);
                            
                            if (hasAccentIssue && hasRoleDiff) {
                                // Both name and role need fixing
                                html += `
                                    <div class="validation-item accent-warning">
                                        <span class="validation-status">‚óê</span>
                                        <div class="validation-name">
                                            <div class="excel-name">${name} ${roleHtml}</div>
                                            <div class="tmdb-name">TMDB: ${match.original} <span class="tmdb-role-diff">(${tmdbJob})</span></div>
                                        </div>
                                        <div class="validation-action validation-action-multi">
                                            <button class="validation-btn fix" onclick="fixName('crew', ${index}, '${escapeQuotes(name)}', '${escapeQuotes(match.original)}', this)">Fix Name</button>
                                            <button class="validation-btn fix-role" onclick="fixRole('crew', '${escapeQuotes(name)}', '${escapeQuotes(roles)}', '${escapeQuotes(tmdbJob)}', this)">Fix Role</button>
                                        </div>
                                    </div>
                                `;
                            } else if (hasAccentIssue) {
                                // Only name needs fixing
                                html += `
                                    <div class="validation-item accent-warning">
                                        <span class="validation-status">‚óê</span>
                                        <div class="validation-name">
                                            <div class="excel-name">${name} ${roleHtml}</div>
                                            <div class="tmdb-name">TMDB: ${match.original}${tmdbJob ? ` <span class="tmdb-role">(${tmdbJob})</span>` : ''}</div>
                                        </div>
                                        <div class="validation-action">
                                            <button class="validation-btn fix" onclick="fixName('crew', ${index}, '${escapeQuotes(name)}', '${escapeQuotes(match.original)}', this)">Fix Name</button>
                                        </div>
                                    </div>
                                `;
                            } else if (hasRoleDiff) {
                                // Only role needs fixing
                                html += `
                                    <div class="validation-item role-warning">
                                        <span class="validation-status"><span class="status-ok">‚úì</span></span>
                                        <div class="validation-name">
                                            <div class="excel-name">${name} ${roleHtml}</div>
                                            <div class="tmdb-match">‚Ü≥ ${match.original} <span class="tmdb-role-diff">(TMDB: ${tmdbJob})</span></div>
                                        </div>
                                        <div class="validation-action">
                                            <button class="validation-btn fix-role" onclick="fixRole('crew', '${escapeQuotes(name)}', '${escapeQuotes(roles)}', '${escapeQuotes(tmdbJob)}', this)">Fix Role</button>
                                        </div>
                                    </div>
                                `;
                            } else {
                                // Both name and role are valid
                                html += `
                                    <div class="validation-item valid">
                                        <span class="validation-status"><span class="status-ok">‚úì</span></span>
                                        <div class="validation-name">
                                            <div class="excel-name">${name} ${roleHtml}</div>
                                            <div class="tmdb-match">‚Ü≥ ${match.original}${tmdbJob ? ` <span class="tmdb-role">(${tmdbJob})</span>` : ''}</div>
                                        </div>
                                    </div>
                                `;
                            }
                        } else if (match.score >= 0.6) {
                            // Check if the similar match has a compatible role
                            const similarHasCompatibleRole = roles && tmdbJob && areRolesEquivalent(roles, tmdbJob);
                            
                            if (similarHasCompatibleRole) {
                                // Similar name with compatible role - suggest fixing name
                                html += `
                                    <div class="validation-item invalid">
                                        <span class="validation-status">‚âà</span>
                                        <div class="validation-name">
                                            <div class="excel-name">${name} ${roleHtml}</div>
                                            <div class="tmdb-name">Similar: ${match.original || 'N/A'}${tmdbJob ? ` <span class="tmdb-role">(${tmdbJob})</span>` : ''}</div>
                                        </div>
                                        <div class="validation-action">
                                            <button class="validation-btn fix" onclick="fixName('crew', ${index}, '${escapeQuotes(name)}', '${escapeQuotes(match.original)}', this)">Fix Name</button>
                                        </div>
                                    </div>
                                `;
                            } else {
                                // Similar name but WRONG role - suggest TMDB's actual person for this role
                                const tmdbPersonForRole = findTmdbCrewByRole(roles, tmdbCrewFull, matchedTmdbCrewNames);
                                
                                if (tmdbPersonForRole) {
                                    const suggestedRole = tmdbPersonForRole.forRole || roles;
                                    html += `
                                        <div class="validation-item not-found">
                                            <span class="validation-status">‚úó</span>
                                            <div class="validation-name">
                                                <div class="excel-name">${name} ${roleHtml}</div>
                                                <div class="tmdb-name">Not found as ${suggestedRole}</div>
                                                <div class="tmdb-suggestion">TMDB ${suggestedRole}: <strong>${tmdbPersonForRole.name}</strong></div>
                                            </div>
                                            <div class="validation-action validation-action-multi">
                                                <button class="validation-btn fix" onclick="fixName('crew', ${index}, '${escapeQuotes(name)}', '${escapeQuotes(tmdbPersonForRole.name)}', this)">Replace</button>
                                                <button class="validation-btn delete" onclick="deleteName('crew', ${index}, '${escapeQuotes(name)}', this)">Delete</button>
                                            </div>
                                        </div>
                                    `;
                                } else {
                                    html += `
                                        <div class="validation-item not-found">
                                            <span class="validation-status">‚úó</span>
                                            <div class="validation-name">
                                                <div class="excel-name">${name} ${roleHtml}</div>
                                                <div class="tmdb-name">Not found in TMDB crew</div>
                                            </div>
                                            <div class="validation-action">
                                                <button class="validation-btn delete" onclick="deleteName('crew', ${index}, '${escapeQuotes(name)}', this)">Delete</button>
                                            </div>
                                        </div>
                                    `;
                                }
                            }
                        } else {
                            // Try alias search
                            const aliasResult = await searchPersonAlias(name, tmdbCrewIds);
                            
                            if (aliasResult.found) {
                                html += `
                                    <div class="validation-item accent-warning">
                                        <span class="validation-status">‚óê</span>
                                        <div class="validation-name">
                                            <div class="excel-name">${name} ${roleHtml}</div>
                                            <div class="tmdb-name">TMDB: ${aliasResult.tmdbName}</div>
                                        </div>
                                        <div class="validation-action">
                                            <button class="validation-btn fix" onclick="fixName('crew', ${index}, '${escapeQuotes(name)}', '${escapeQuotes(aliasResult.tmdbName)}', this)">Fix Name</button>
                                        </div>
                                    </div>
                                `;
                            } else {
                                // Not found - suggest TMDB's person for this role
                                const tmdbPersonForRole = findTmdbCrewByRole(roles, tmdbCrewFull, matchedTmdbCrewNames);
                                
                                if (tmdbPersonForRole) {
                                    const suggestedRole = tmdbPersonForRole.forRole || roles;
                                    html += `
                                        <div class="validation-item not-found">
                                            <span class="validation-status">‚úó</span>
                                            <div class="validation-name">
                                                <div class="excel-name">${name} ${roleHtml}</div>
                                                <div class="tmdb-name">Not found in TMDB</div>
                                                <div class="tmdb-suggestion">TMDB ${suggestedRole}: <strong>${tmdbPersonForRole.name}</strong></div>
                                            </div>
                                            <div class="validation-action validation-action-multi">
                                                <button class="validation-btn fix" onclick="fixName('crew', ${index}, '${escapeQuotes(name)}', '${escapeQuotes(tmdbPersonForRole.name)}', this)">Replace</button>
                                                <button class="validation-btn delete" onclick="deleteName('crew', ${index}, '${escapeQuotes(name)}', this)">Delete</button>
                                            </div>
                                        </div>
                                    `;
                                } else {
                                    html += `
                                        <div class="validation-item not-found">
                                            <span class="validation-status">‚úó</span>
                                            <div class="validation-name">
                                                <div class="excel-name">${name} ${roleHtml}</div>
                                                <div class="tmdb-name">Not found in TMDB</div>
                                            </div>
                                            <div class="validation-action">
                                                <button class="validation-btn delete" onclick="deleteName('crew', ${index}, '${escapeQuotes(name)}', this)">Delete</button>
                                            </div>
                                        </div>
                                    `;
                                }
                            }
                        }
                    }
                    
                    // Check for missing Director - suggest from TMDB
                    const hasDirector = crewNames.some(item => {
                        const role = item.roles ? item.roles.toLowerCase() : '';
                        return role.includes('director') && !role.includes('co-director');
                    });
                    
                    if (!hasDirector) {
                        // Find Director(s) from TMDB crew
                        const tmdbDirectors = tmdbCrewFull.filter(c => 
                            c.job && c.job.toLowerCase() === 'director'
                        );
                        
                        if (tmdbDirectors.length > 0) {
                            html += `<div class="validation-subsection">`;
                            html += `<div class="validation-subsection-title">‚ö†Ô∏è Missing Director - TMDB suggestion</div>`;
                            
                            for (const director of tmdbDirectors) {
                                html += `
                                    <div class="validation-item suggestion">
                                        <span class="validation-status">+</span>
                                        <div class="validation-name">
                                            <div class="excel-name">${director.name} <span class="role-tag">Director</span></div>
                                            <div class="tmdb-name">From TMDB credits</div>
                                        </div>
                                        <div class="validation-action">
                                            <button class="validation-btn add" onclick="addCrewMember('${escapeQuotes(director.name)}', 'Director', this)">Add</button>
                                        </div>
                                    </div>
                                `;
                            }
                            
                            html += `</div>`;
                        }
                    }
                    
                    html += `</div>`;
                } else {
                    // No crew in XML - still check for missing Director from TMDB
                    const tmdbDirectors = tmdbCrewFull.filter(c => 
                        c.job && c.job.toLowerCase() === 'director'
                    );
                    
                    if (tmdbDirectors.length > 0) {
                        html += `<div class="validation-section">`;
                        html += `<div class="validation-section-title">Crew (0)</div>`;
                        html += `<div class="validation-subsection">`;
                        html += `<div class="validation-subsection-title">‚ö†Ô∏è Missing Director - TMDB suggestion</div>`;
                        
                        for (const director of tmdbDirectors) {
                            html += `
                                <div class="validation-item suggestion">
                                    <span class="validation-status">+</span>
                                    <div class="validation-name">
                                        <div class="excel-name">${director.name} <span class="role-tag">Director</span></div>
                                        <div class="tmdb-name">From TMDB credits</div>
                                    </div>
                                    <div class="validation-action">
                                        <button class="validation-btn add" onclick="addCrewMember('${escapeQuotes(director.name)}', 'Director', this)">Add</button>
                                    </div>
                                </div>
                            `;
                        }
                        
                        html += `</div>`;
                        html += `</div>`;
                    }
                }
                
                if (!html) {
                    html = `
                        <div class="validation-placeholder">
                            <span class="validation-icon">üìã</span>
                            <p>No cast or crew data in XML</p>
                        </div>
                    `;
                }
                
                validationList.innerHTML = html;
                
            } catch (error) {
                console.error('Error validating cast/crew:', error);
                validationList.innerHTML = `
                    <div class="validation-placeholder">
                        <span class="validation-icon">‚ö†Ô∏è</span>
                        <p>Error validating data</p>
                    </div>
                `;
            }
        }

        // Extract display names from generated XML
        // Extract display names from generated XML (with roles for crew)
        function extractNamesFromXML(xml, memberType) {
            const results = [];
            const seenNames = new Set();
            
            if (memberType === 'crew_member') {
                // For crew, extract name and roles
                const regex = /<crew_member>[\s\S]*?<display_name>([^<]+)<\/display_name>[\s\S]*?<roles>([\s\S]*?)<\/roles>[\s\S]*?<\/crew_member>/gi;
                let match;
                
                while ((match = regex.exec(xml)) !== null) {
                    const name = match[1].trim();
                    const rolesBlock = match[2];
                    
                    // Extract individual roles
                    const roles = [];
                    const roleRegex = /<role>([^<]+)<\/role>/gi;
                    let roleMatch;
                    while ((roleMatch = roleRegex.exec(rolesBlock)) !== null) {
                        roles.push(roleMatch[1].trim());
                    }
                    
                    if (name && !seenNames.has(name)) {
                        seenNames.add(name);
                        results.push({ name, roles: roles.join(', ') });
                    }
                }
            } else {
                // For cast, extract names and character names
                const regex = /<cast_member>([\s\S]*?)<\/cast_member>/gi;
                let match;
                
                while ((match = regex.exec(xml)) !== null) {
                    const block = match[1];
                    
                    // Extract display name
                    const nameMatch = block.match(/<display_name>([^<]+)<\/display_name>/i);
                    const name = nameMatch ? nameMatch[1].trim() : '';
                    
                    // Extract character name
                    const charMatch = block.match(/<character_name>([^<]*)<\/character_name>/i);
                    const character = charMatch ? charMatch[1].trim() : '';
                    
                    if (name && !seenNames.has(name)) {
                        seenNames.add(name);
                        results.push({ name, roles: character });
                    }
                }
            }
            
            return results;
        }

        // Normalize name for comparison
        function normalizeName(name) {
            if (!name) return '';
            return name
                .toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') // Remove accents
                .replace(/[^a-z\s]/g, '') // Remove non-letters
                .replace(/\s+/g, ' ')
                .trim();
        }

        // Find TMDB crew member by role (optionally excluding already matched names)
        function findTmdbCrewByRole(xmlRole, tmdbCrewFull, excludeNames = null) {
            if (!xmlRole || !tmdbCrewFull) return null;
            
            // Handle multiple roles (e.g., "Director, Screenwriter")
            const roles = xmlRole.split(/,\s*/).map(r => r.trim());
            
            // Define role mappings
            const roleGroups = {
                'director': ['Director', 'Co-Director'],
                'co director': ['Co-Director', 'Director'],
                'screenwriter': ['Writer', 'Screenplay', 'Screenwriter', 'Story', 'Author'],
                'writer': ['Writer', 'Screenplay', 'Screenwriter', 'Story', 'Book', 'Novel', 'Author'],
                'author': ['Writer', 'Screenplay', 'Screenwriter', 'Story', 'Book', 'Novel', 'Author'],
                'producer': ['Producer', 'Executive Producer', 'Co-Producer'],
                'executive producer': ['Executive Producer', 'Producer'],
                'composer': ['Original Music Composer', 'Composer', 'Music']
            };
            
            // Try each role, prioritizing Director
            for (const role of roles) {
                const normalizedRole = normalizeName(role);
                
                // Get the jobs to look for
                let targetJobs = roleGroups[normalizedRole] || [role];
                
                // Find first crew member with matching role (excluding already matched names)
                for (const job of targetJobs) {
                    const found = tmdbCrewFull.find(c => {
                        if (!c.job || c.job.toLowerCase() !== job.toLowerCase()) return false;
                        // Skip if this person is already matched
                        if (excludeNames && excludeNames.has(c.name.toLowerCase())) return false;
                        return true;
                    });
                    if (found) {
                        return { ...found, forRole: role };
                    }
                }
            }
            
            return null;
        }

        // iTunes only allows these crew roles
        const ITUNES_ALLOWED_ROLES = ['Co-Director', 'Director', 'Producer', 'Screenwriter', 'Composer', 'Dub Artist'];
        
        // Map any role to iTunes allowed role
        function mapToItunesRole(role) {
            if (!role) return null;
            const normalized = role.toLowerCase().trim();
            
            // Dub Artist (check first since "dub director" should be Dub Artist, not Director)
            if (normalized.includes('dub') || normalized.includes('doublage')) return 'Dub Artist';
            
            // Director family
            if (normalized.includes('director') && (normalized.includes('co') || normalized.includes('co-'))) return 'Co-Director';
            if (normalized.includes('director') || normalized.includes('r√©alisateur') || normalized.includes('realisateur')) return 'Director';
            
            // Producer family (all producer types become Producer)
            if (normalized.includes('producer') || normalized.includes('producteur')) return 'Producer';
            
            // Writer family (all become Screenwriter)
            if (normalized.includes('writer') || normalized.includes('screenplay') || 
                normalized.includes('sc√©nariste') || normalized.includes('scenariste') ||
                normalized.includes('screenwriter') || normalized.includes('scenarist') || 
                normalized.includes('author') || normalized.includes('auteur')) return 'Screenwriter';
            
            // Composer
            if (normalized.includes('composer') || normalized.includes('compositeur') ||
                normalized.includes('music by') || normalized.includes('original music')) return 'Composer';
            
            // If no mapping found, return null
            return null;
        }

        // Check if roles are equivalent (for crew validation)
        function areRolesEquivalent(xmlRole, tmdbRole) {
            if (!xmlRole || !tmdbRole) return false;
            
            const normalizedXml = normalizeName(xmlRole);
            const normalizedTmdb = normalizeName(tmdbRole);
            
            // Exact match
            if (normalizedXml === normalizedTmdb) return true;
            
            // Define equivalent role groups
            const producerRoles = ['producer', 'executive producer', 'co producer', 'coproducer', 'production director'];
            const writerRoles = ['writer', 'screenplay', 'screenwriter', 'writers assistant', 'book', 'novel', 'story', 'original story', 'author'];
            const directorRoles = ['director', 'co director', 'codirector'];
            
            // Check if both are in the same producer family
            const isXmlProducer = producerRoles.some(r => normalizedXml.includes(r));
            const isTmdbProducer = producerRoles.some(r => normalizedTmdb.includes(r));
            if (isXmlProducer && isTmdbProducer) return true;
            
            // Check if both are in the same writer family
            const isXmlWriter = writerRoles.some(r => normalizedXml.includes(r));
            const isTmdbWriter = writerRoles.some(r => normalizedTmdb.includes(r));
            if (isXmlWriter && isTmdbWriter) return true;
            
            // If XML has multiple roles (comma-separated in original), check if TMDB role is one of them
            // Example: "Director, Writer" contains "Director"
            // Split the original role string before normalizing
            const xmlRoleParts = xmlRole.split(/,\s*/).map(r => normalizeName(r.trim()));
            if (xmlRoleParts.length > 1) {
                // Check if TMDB role matches any of the XML roles
                if (xmlRoleParts.includes(normalizedTmdb)) return true;
                
                // Check if TMDB role is in the same family as any XML role
                for (const xmlR of xmlRoleParts) {
                    // Director family
                    if (directorRoles.includes(xmlR) && directorRoles.includes(normalizedTmdb)) return true;
                    // Writer family  
                    if (writerRoles.some(w => xmlR.includes(w)) && writerRoles.some(w => normalizedTmdb.includes(w))) return true;
                    // Producer family
                    if (producerRoles.some(p => xmlR.includes(p)) && producerRoles.some(p => normalizedTmdb.includes(p))) return true;
                }
            }
            
            return false;
        }

        // Check if character names are equivalent (for cast validation)
        function areCharactersEquivalent(xmlChar, tmdbChar) {
            if (!xmlChar || !tmdbChar) return false;
            
            // For character names, we want exact match (case-sensitive, accent-sensitive)
            // "PAUL" is different from "Paul", "√âlisabeth" is different from "Elisabeth"
            return xmlChar.trim() === tmdbChar.trim();
        }

        // Parse Excel cast data for validation
        function parseExcelCast(castValue) {
            if (!castValue) return [];
            
            const cast = [];
            
            // First split by newlines, then by multiple spaces (3+) for entries on same line
            const lines = castValue.split(/[\r\n]+/).filter(Boolean);
            const entries = [];
            lines.forEach(line => {
                // Split by 3+ spaces to separate multiple entries on same line
                const parts = line.split(/\s{3,}/).filter(Boolean);
                entries.push(...parts);
            });
            
            entries.forEach(entry => {
                entry = entry.trim();
                if (!entry) return;
                
                // Handle "Actor : Character (AltName)" format - double role pattern
                // e.g., "Beno√Æt POELVOORDE : Jean Chevalin (Jacob)"
                const colonWithParenMatch = entry.match(/^(.+?)\s*:\s*(.+?)\s*\(([^)]+)\)\s*$/);
                if (colonWithParenMatch) {
                    const actor = toProperCase(colonWithParenMatch[1].trim());
                    const character = colonWithParenMatch[2].trim();
                    const altName = colonWithParenMatch[3].trim();
                    // Combine as "Character /AltName"
                    cast.push({ name: actor, character: `${character} /${altName}` });
                    return;
                }
                
                // Handle dots/ellipsis separator
                // Matches: "...", "..", "‚Ä¶", " ‚Ä¶ ", "‚Ä¶.." etc.
                const dotsMatch = entry.match(/^(.+?)\s*(?:\.{2,}|‚Ä¶+|\.+‚Ä¶|‚Ä¶\.+)\s*(.+)$/);
                if (dotsMatch) {
                    // Clean leading dots/periods from character name
                    const character = dotsMatch[2].replace(/^[\.‚Ä¶\s]+/, '').trim();
                    cast.push({ name: toProperCase(dotsMatch[1].trim()), character: character });
                    return;
                }
                
                // Handle slash separator: "Name / Character"
                if (entry.includes(' / ')) {
                    const parts = entry.split(' / ').map(s => s.trim());
                    if (parts.length >= 2) {
                        cast.push({ name: toProperCase(parts[0]), character: parts[1] });
                        return;
                    }
                }
                
                // Handle dash separator: "Name - Character"
                if (entry.includes(' - ')) {
                    const parts = entry.split(' - ').map(s => s.trim());
                    if (parts.length >= 2) {
                        cast.push({ name: toProperCase(parts[0]), character: parts[1] });
                        return;
                    }
                }
                
                // Handle equals separator: "Name = Character"
                if (entry.includes(' = ')) {
                    const parts = entry.split(' = ').map(s => s.trim());
                    if (parts.length >= 2) {
                        cast.push({ name: toProperCase(parts[0]), character: parts[1] });
                        return;
                    }
                }
                
                // Handle parentheses: "Name (Character)"
                if (entry.includes('(') && entry.includes(')') && !entry.includes(':')) {
                    const match = entry.match(/(.+?)\s*\(([^)]+)\)/);
                    if (match) {
                        cast.push({ name: toProperCase(match[1].trim()), character: match[2].trim() });
                        return;
                    }
                }
                
                // Handle colon separator: "Actor : Character"
                if (entry.includes(' : ') || entry.includes(': ')) {
                    const parts = entry.split(/\s*:\s*/).map(s => s.trim());
                    if (parts.length >= 2) {
                        // Heuristic to detect order
                        const firstWords = parts[0].split(/\s+/);
                        const secondWords = parts[1].split(/\s+/);
                        
                        const articles = ['le', 'la', 'les', 'l\'', 'un', 'une', 'the', 'a', 'an'];
                        const firstStartsWithArticle = articles.includes(firstWords[0].toLowerCase());
                        const secondStartsWithArticle = articles.includes(secondWords[0].toLowerCase());
                        
                        const isNameWord = (w) => w.length >= 2 && /^[A-Z√Ä-√ú]/.test(w) && !articles.includes(w.toLowerCase());
                        const firstNameWords = firstWords.filter(isNameWord).length;
                        const secondNameWords = secondWords.filter(isNameWord).length;
                        
                        let isActorFirst = true;
                        
                        if (firstStartsWithArticle && !secondStartsWithArticle) {
                            isActorFirst = false;
                        } else if (secondStartsWithArticle && !firstStartsWithArticle) {
                            isActorFirst = true;
                        } else if (firstNameWords >= 2 && secondNameWords <= 1) {
                            isActorFirst = true;
                        } else if (secondNameWords >= 2 && firstNameWords <= 1) {
                            isActorFirst = false;
                        }
                        
                        if (isActorFirst) {
                            cast.push({ name: toProperCase(parts[0]), character: parts[1] });
                        } else {
                            cast.push({ name: toProperCase(parts[1]), character: parts[0] });
                        }
                        return;
                    }
                }
                
                // No separator found, treat as just an actor name
                if (entry.trim()) {
                    cast.push({ name: toProperCase(entry.trim()), character: '' });
                }
            });
            
            return cast;
        }

        // Parse Excel crew data for validation
        function parseExcelCrew(crewData) {
            if (!crewData || crewData.length === 0) return [];
            
            const crew = [];
            const roleMap = {
                'R√©alisateur': 'Director',
                'Sc√©nariste': 'Writer',
                'Producteur': 'Producer',
                'Producteurs Ex√©cutifs': 'Executive Producer'
            };
            
            // Production company indicators to filter out
            const productionIndicators = [
                'Productions', 'Production', 'Films', 'Studio', 'Entertainment', 
                'Pictures', 'Cin√©ma', 'Cinema', 'RTBF', 'TV', 'T√©l√©vision',
                'Art', 'Media', 'VOO', 'Be Tv', 'France 2', 'France 3', 'TF1',
                'Canal', 'M6', 'Arte', 'Pan Cin√©ma', 'Pan '
            ];
            
            function isProductionCompany(name) {
                const lower = name.toLowerCase();
                return productionIndicators.some(ind => lower.includes(ind.toLowerCase()));
            }
            
            // Helper to check if a word is ALL CAPS
            function isWordAllCaps(word) {
                const letters = word.replace(/[^a-zA-Z√Ä-√ø]/g, '');
                return letters.length > 1 && letters === letters.toUpperCase();
            }
            
            // Helper to check if a word starts with uppercase but isn't all caps (typical first name)
            function isFirstNamePattern(word) {
                const letters = word.replace(/[^a-zA-Z√Ä-√ø]/g, '');
                if (letters.length < 2) return false;
                return /^[A-Z√Ä-√ú]/.test(letters) && letters !== letters.toUpperCase();
            }
            
            // Split concatenated names like "Rapha√´le MOUSSAFIR St√©phane KAZANDJAN"
            function splitConcatenatedNames(text) {
                const words = text.trim().split(/\s+/);
                if (words.length < 4) return [text]; // Need at least 4 words for 2 names
                
                const names = [];
                let currentName = [];
                
                for (let i = 0; i < words.length; i++) {
                    const word = words[i];
                    currentName.push(word);
                    
                    // Check if this is an ALL CAPS word followed by a first-name pattern
                    // That indicates a boundary between two names
                    if (i < words.length - 1 && isWordAllCaps(word) && isFirstNamePattern(words[i + 1])) {
                        // End current name, start new one
                        if (currentName.length >= 2) {
                            names.push(currentName.join(' '));
                            currentName = [];
                        }
                    }
                }
                
                // Add remaining name
                if (currentName.length > 0) {
                    names.push(currentName.join(' '));
                }
                
                return names.length > 0 ? names : [text];
            }
            
            crewData.forEach(crewEntry => {
                if (!crewEntry.names) return;
                
                const englishRole = roleMap[crewEntry.role] || crewEntry.role;
                const lines = crewEntry.names.split(/[\r\n]+/).filter(line => line.trim() !== '');
                
                lines.forEach(line => {
                    // Split by comma, double spaces, ET/AND/&
                    // Order matters: first comma, then double space, then ET/AND/&
                    let names = line.split(/,/).flatMap(part => 
                        part.split(/\s{2,}/).flatMap(subpart =>
                            subpart.split(/\s+(?:ET|AND|&)\s+/i)
                        )
                    );
                    
                    // Further split concatenated names like "FirstName LASTNAME FirstName LASTNAME"
                    names = names.flatMap(name => splitConcatenatedNames(name));
                    
                    names.forEach(name => {
                        name = name.trim();
                        if (!name) return;
                        
                        // Skip production companies
                        if (isProductionCompany(name)) return;
                        
                        // Skip if all caps (likely a company name)
                        if (isAllCaps(name) && name.length > 3) return;
                        
                        crew.push({ name: toProperCase(name), role: englishRole });
                    });
                });
            });
            
            return crew;
        }

        // Find best matching name using similarity
        function findBestMatch(name, candidates, originalCandidates = null) {
            let bestScore = 0;
            let bestMatch = null;
            let bestOriginal = null;
            let bestIndex = -1;
            
            candidates.forEach((candidate, index) => {
                const score = stringSimilarity(name, candidate);
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = candidate;
                    bestIndex = index;
                    bestOriginal = originalCandidates ? originalCandidates[index] : candidate;
                }
            });
            
            return { score: bestScore, match: bestMatch, original: bestOriginal, index: bestIndex };
        }

        // Check if two names have accent differences
        function hasAccentDifference(name1, name2) {
            if (!name1 || !name2) return false;
            const normalized1 = normalizeName(name1);
            const normalized2 = normalizeName(name2);
            const lower1 = name1.toLowerCase().trim();
            const lower2 = name2.toLowerCase().trim();
            
            // If lowercase versions are different, there's a difference worth fixing
            // This catches both accent differences AND minor spelling differences
            // e.g., "Salignac" vs "S√©lignac" or "Stephane" vs "St√©phane"
            if (lower1 !== lower2) {
                // Check if the difference is minor enough (high similarity)
                const similarity = stringSimilarity(normalized1, normalized2);
                if (similarity >= 0.85) {
                    return true; // Flag as needing fix
                }
            }
            
            return false;
        }

        // Search for a person by name and check if they're in the movie credits via aliases
        async function searchPersonAlias(name, movieCreditIds) {
            try {
                // Search for the person on TMDB
                const data = await tmdbFetch('search/person', `query=${encodeURIComponent(name)}`);
                
                if (!data.results || data.results.length === 0) {
                    return { found: false };
                }
                
                // Check if any of the search results are in the movie credits
                for (const person of data.results.slice(0, 3)) { // Check top 3 results
                    if (movieCreditIds.includes(person.id)) {
                        // Found! Get the person's primary TMDB name
                        const personData = await tmdbFetch(`person/${person.id}`);
                        
                        return {
                            found: true,
                            tmdbName: personData.name,
                            personId: person.id
                        };
                    }
                }
                
                // Also check by fetching person details and comparing aliases
                for (const person of data.results.slice(0, 3)) {
                    const personData = await tmdbFetch(`person/${person.id}`);
                    
                    // Check if person ID is in credits
                    if (movieCreditIds.includes(personData.id)) {
                        return {
                            found: true,
                            tmdbName: personData.name,
                            personId: personData.id
                        };
                    }
                    
                    // Check if any alias matches a name in movie credits
                    const aliases = personData.also_known_as || [];
                    const normalizedSearchName = normalizeName(name);
                    
                    for (const alias of aliases) {
                        if (normalizeName(alias) === normalizedSearchName) {
                            // This person has the search name as an alias, check if they're in credits
                            if (movieCreditIds.includes(personData.id)) {
                                return {
                                    found: true,
                                    tmdbName: personData.name,
                                    personId: personData.id
                                };
                            }
                        }
                    }
                }
                
                return { found: false };
            } catch (error) {
                console.error('Error searching person alias:', error);
                return { found: false };
            }
        }

        // Calculate string similarity (Levenshtein-based)
        function stringSimilarity(s1, s2) {
            if (s1 === s2) return 1;
            if (!s1 || !s2) return 0;
            
            const longer = s1.length > s2.length ? s1 : s2;
            const shorter = s1.length > s2.length ? s2 : s1;
            
            if (longer.length === 0) return 1;
            
            const costs = [];
            for (let i = 0; i <= s1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= s2.length; j++) {
                    if (i === 0) {
                        costs[j] = j;
                    } else if (j > 0) {
                        let newValue = costs[j - 1];
                        if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                        }
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
                if (i > 0) costs[s2.length] = lastValue;
            }
            
            return (longer.length - costs[s2.length]) / longer.length;
        }

        // Normalize synopsis - remove extra line breaks and empty lines
        function normalizeSynopsis(synopsis) {
            if (!synopsis) return '';
            
            const NBSP = '\u00A0'; // Non-breaking space
            
            return synopsis
                // Replace Windows line endings with Unix
                .replace(/\r\n/g, '\n')
                // Replace carriage returns
                .replace(/\r/g, '\n')
                // Replace multiple consecutive newlines (with optional spaces) with a single space
                .replace(/\n\s*\n/g, ' ')
                // Replace single newlines with space
                .replace(/\n/g, ' ')
                // Replace ‚Ä¶ (ellipsis) with ...
                .replace(/‚Ä¶/g, '...')
                // Replace oe with ≈ì ligature (common French words)
                .replace(/\bcoeur\b/gi, m => m[0] === 'C' ? 'C≈ìur' : 'c≈ìur')
                .replace(/\bsoeur\b/gi, m => m[0] === 'S' ? 'S≈ìur' : 's≈ìur')
                .replace(/\boeuvre\b/gi, m => m[0] === 'O' ? '≈íuvre' : '≈ìuvre')
                .replace(/\boeuf\b/gi, m => m[0] === 'O' ? '≈íuf' : '≈ìuf')
                .replace(/\boeil\b/gi, m => m[0] === 'O' ? '≈íil' : '≈ìil')
                // French typography: non-breaking space after ¬´ and before ¬ª
                .replace(/¬´\s*/g, '¬´' + NBSP)
                .replace(/\s*¬ª/g, NBSP + '¬ª')
                // French typography: non-breaking space before ! ? : ;
                .replace(/\s+!/g, NBSP + '!')
                .replace(/\s+\?/g, NBSP + '?')
                .replace(/\s+:/g, NBSP + ':')
                .replace(/\s+;/g, NBSP + ';')
                // Collapse multiple spaces into one
                .replace(/\s{2,}/g, ' ')
                // Trim
                .trim();
        }

        function cleanCopyright(copyrightValue) {
            if (!copyrightValue) return '';
            
            // Remove ¬© and @ symbols
            let cleaned = copyrightValue.replace(/[¬©@]/g, '').trim();
            
            // Remove leading/trailing dashes
            cleaned = cleaned.replace(/^[-‚Äì]+|[-‚Äì]+$/g, '').trim();
            
            // Remove trailing period
            cleaned = cleaned.replace(/\.\s*$/, '').trim();
            
            // Extract year (4 digits)
            const yearMatch = cleaned.match(/(\d{4})/);
            const year = yearMatch ? yearMatch[1] : '';
            
            // Remove the year from the string to get production companies
            let companiesPart = cleaned.replace(/\d{4}/, '').trim();
            
            // Remove leading dashes/slashes after year removal
            companiesPart = companiesPart.replace(/^[-‚Äì\/\s]+/, '').trim();
            
            // Split by comma, slash, dash, or emdash to get individual companies
            const companies = companiesPart.split(/\s*[,\/‚Äì-]\s*/).filter(c => c.trim());
            
            // Format all production companies
            const formattedCompanies = companies.map(c => formatCompanyName(c.trim())).filter(Boolean);
            
            // Return "year Company1 / Company2 / Company3" format
            if (year && formattedCompanies.length > 0) {
                return `${year} ${formattedCompanies.join(' / ')}`;
            } else if (year) {
                return year;
            } else if (formattedCompanies.length > 0) {
                return formattedCompanies.join(' / ');
            }
            
            return '';
        }
        
        function formatCompanyName(name) {
            if (!name) return '';
            
            // Remove content in parentheses (e.g., "(YZE)" abbreviations)
            name = name.replace(/\s*\([^)]*\)/g, '').trim();
            
            // Remove any stray closing parentheses
            name = name.replace(/\)+/g, '').trim();
            
            // List of words that should stay lowercase (unless at the beginning)
            const lowercaseWords = ['de', 'du', 'et', 'la', 'le', 'les'];
            
            // List of known acronyms that should stay uppercase
            const acronyms = ['TV', 'USA', 'UK', 'BBC', 'HBO', 'ABC', 'CBS', 'NBC'];
            
            // Split by spaces
            const words = name.split(/\s+/);
            
            const formatted = words.map((word, index) => {
                // Check if it's a number
                if (/^\d+$/.test(word)) {
                    return word;
                }
                
                // Check if it's a known acronym
                if (acronyms.includes(word.toUpperCase())) {
                    return word.toUpperCase();
                }
                
                // Check if it should be lowercase (but not if it's the first word)
                if (index > 0 && lowercaseWords.includes(word.toLowerCase())) {
                    return word.toLowerCase();
                }
                
                // Otherwise, apply title case
                return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
            });
            
            return formatted.join(' ');
        }

        function parseGenres(genreValue) {
            if (!genreValue) return '';
            
            // iTunes genre code to display name mapping
            const ITUNES_GENRES = {
                'ACTION-ADVENTURE-00': 'Action & Adventure',
                'AFRICAN-00': 'African',
                'ANIME-00': 'Anime',
                'BOLLYWOOD-00': 'Bollywood',
                'CLASSICS-00': 'Classics',
                'COMEDY-00': 'Comedy',
                'CONCERT-FILMS-00': 'Concert Films',
                'DOCUMENTARY-00': 'Documentary',
                'DRAMA-00': 'Drama',
                'FOREIGN-00': 'Foreign',
                'HOLIDAY-00': 'Holiday',
                'HORROR-00': 'Horror',
                'INDEPENDENT-00': 'Independent',
                'KIDS-FAMILY-00': 'Kids & Family',
                'MADE-FOR-TV-00': 'Made for TV',
                'MIDDLE-EASTERN-00': 'Middle Eastern',
                'MUSIC-DOCUMENTARIES-00': 'Music Documentary',
                'MUSIC-FEATURE-FILMS-00': 'Music Feature Film',
                'MUSICALS-00': 'Musicals',
                'REGIONAL-INDIAN-00': 'Regional Indian',
                'ROMANCE-00': 'Romance',
                'RUSSIAN-00': 'Russian',
                'SCIFI-FANTASY-00': 'Sci-Fi & Fantasy',
                'SHORT-FILMS-00': 'Short Films',
                'SPECIAL-INTEREST-00': 'Special Interest',
                'SPORTS-00': 'Sports',
                'THRILLER-00': 'Thriller',
                'TURKISH-00': 'Turkish',
                'URBAN-00': 'Urban',
                'WESTERN-00': 'Western'
            };
            
            // Mapping from French/common genre names to iTunes codes
            const GENRE_MAPPING = {
                'com√©die': 'COMEDY-00',
                'comedie': 'COMEDY-00',
                'comedy': 'COMEDY-00',
                'drame': 'DRAMA-00',
                'drama': 'DRAMA-00',
                'action': 'ACTION-ADVENTURE-00',
                'aventure': 'ACTION-ADVENTURE-00',
                'adventure': 'ACTION-ADVENTURE-00',
                'thriller': 'THRILLER-00',
                'horreur': 'HORROR-00',
                'horror': 'HORROR-00',
                'romance': 'ROMANCE-00',
                'romantique': 'ROMANCE-00',
                'animation': 'KIDS-FAMILY-00',
                'anim√©': 'ANIME-00',
                'anime': 'ANIME-00',
                'documentaire': 'DOCUMENTARY-00',
                'documentary': 'DOCUMENTARY-00',
                'famille': 'KIDS-FAMILY-00',
                'family': 'KIDS-FAMILY-00',
                'enfants': 'KIDS-FAMILY-00',
                'kids': 'KIDS-FAMILY-00',
                'science-fiction': 'SCIFI-FANTASY-00',
                'sci-fi': 'SCIFI-FANTASY-00',
                'fantastique': 'SCIFI-FANTASY-00',
                'fantasy': 'SCIFI-FANTASY-00',
                'musical': 'MUSICALS-00',
                'musicals': 'MUSICALS-00',
                'western': 'WESTERN-00',
                'guerre': 'ACTION-ADVENTURE-00',
                'war': 'ACTION-ADVENTURE-00',
                'policier': 'THRILLER-00',
                'crime': 'THRILLER-00',
                'biopic': 'DRAMA-00',
                'biographie': 'DRAMA-00',
                'biography': 'DRAMA-00',
                'historique': 'DRAMA-00',
                'history': 'DRAMA-00',
                'sport': 'SPORTS-00',
                'sports': 'SPORTS-00',
                'ind√©pendant': 'INDEPENDENT-00',
                'independent': 'INDEPENDENT-00',
                'classique': 'CLASSICS-00',
                'classics': 'CLASSICS-00',
                '√©tranger': 'FOREIGN-00',
                'foreign': 'FOREIGN-00',
                'dramatique': 'DRAMA-00'
            };
            
            const normalizedValue = genreValue.toLowerCase().trim();
            
            // Check for compound French genres
            const compoundPatterns = [
                { pattern: /com[√©e]die\s+dramatique/i, genres: ['COMEDY-00', 'DRAMA-00'] },
                { pattern: /drame\s+com[√©e]die/i, genres: ['DRAMA-00', 'COMEDY-00'] },
                { pattern: /action\s+aventure/i, genres: ['ACTION-ADVENTURE-00'] },
                { pattern: /science[- ]fiction/i, genres: ['SCIFI-FANTASY-00'] },
                { pattern: /com[√©e]die\s+romantique/i, genres: ['COMEDY-00', 'ROMANCE-00'] },
                { pattern: /thriller\s+dramatique/i, genres: ['THRILLER-00', 'DRAMA-00'] },
                { pattern: /drame\s+historique/i, genres: ['DRAMA-00'] },
                { pattern: /com[√©e]die\s+musicale/i, genres: ['COMEDY-00', 'MUSICALS-00'] }
            ];
            
            let genreCodes = [];
            
            // Check for compound patterns first
            for (const cp of compoundPatterns) {
                if (cp.pattern.test(normalizedValue)) {
                    genreCodes = cp.genres;
                    break;
                }
            }
            
            // If no compound pattern matched, split and map individually
            if (genreCodes.length === 0) {
                const genreList = genreValue.split(/[\r\n,\/]+|\s+et\s+|\s+and\s+|&/).map(g => g.trim().toLowerCase()).filter(Boolean);
                
                for (const genre of genreList) {
                    const code = GENRE_MAPPING[genre];
                    if (code && !genreCodes.includes(code)) {
                        genreCodes.push(code);
                    }
                }
            }
            
            // Build XML output: <genre code="COMEDY-00">Comedy</genre>
            let genresXML = '';
            for (const code of genreCodes) {
                const displayName = ITUNES_GENRES[code];
                if (displayName) {
                    genresXML += `
      <genre code="${code}">${displayName}</genre>`;
                }
            }
            
            return genresXML;
        }

        function parseRating(ratingValue) {
            return RATING_CODES[ratingValue] || 'TP';
        }

        function parseCast(castValue, useV52Format = false) {
            if (!castValue) return '';
            
            let castXML = '';
            let castMembers = [];
            
            // First, try to parse the comma-separated format: "Name (Character), Name (Character)"
            // This handles the Diplodocus and Indomptables format
            if (castValue.includes('(') && castValue.includes(')') && castValue.includes(',')) {
                // Split by comma that's not inside parentheses
                const entries = castValue.split(/,(?![^(]*\))/).map(s => s.trim()).filter(Boolean);
                
                let allMatchParentheses = true;
                const tempMembers = [];
                
                entries.forEach(entry => {
                    const match = entry.match(/(.+?)\s*\(([^)]+)\)/);
                    if (match) {
                        const actor = toProperCase(match[1].trim());
                        const character = match[2].trim();
                        tempMembers.push({ actor, character });
                    } else {
                        allMatchParentheses = false;
                    }
                });
                
                if (allMatchParentheses && tempMembers.length > 0) {
                    castMembers = tempMembers;
                }
            }
            
            // If no cast members found yet, try other formats
            if (castMembers.length === 0) {
                // Split by line breaks or 3+ spaces
                const entries = castValue.split(/[\r\n]+|\s{3,}/).filter(Boolean);
                
                entries.forEach(entry => {
                    let actor = '', character = '';
                    
                    // Check for "Actor : Character (AltName)" format - double role pattern
                    // e.g., "Beno√Æt POELVOORDE : Jean Chevalin (Jacob)"
                    const colonWithParenMatch = entry.match(/^(.+?)\s*:\s*(.+?)\s*\(([^)]+)\)\s*$/);
                    if (colonWithParenMatch) {
                        actor = toProperCase(colonWithParenMatch[1].trim());
                        const charName = colonWithParenMatch[2].trim();
                        const altName = colonWithParenMatch[3].trim();
                        // Combine as "Character /AltName"
                        character = `${charName} /${altName}`;
                        castMembers.push({ actor, character });
                        return;
                    }
                    
                    // Check for format with dots or ellipsis
                    // Matches: "...", "..", "‚Ä¶", "‚Ä¶..", " ‚Ä¶ ", "‚Ä¶." etc.
                    // Pattern: 2+ regular dots OR 1+ ellipsis character (with optional spaces)
                    const dotsMatch = entry.match(/^(.+?)\s*(?:\.{2,}|‚Ä¶+|\.+‚Ä¶|‚Ä¶\.+)\s*(.+)$/);
                    if (dotsMatch) {
                        actor = toProperCase(dotsMatch[1].trim());
                        // Clean leading dots/periods from character name
                        character = dotsMatch[2].replace(/^[\.‚Ä¶\s]+/, '').trim();
                        castMembers.push({ actor, character });
                        return;
                    }
                    
                    // Check for format: "Name / Character" with slash separator
                    if (entry.includes(' / ')) {
                        const parts = entry.split(' / ').map(s => s.trim());
                        if (parts.length >= 2) {
                            actor = toProperCase(parts[0]);
                            character = parts[1];
                            castMembers.push({ actor, character });
                            return;
                        }
                    }
                    
                    // Check for format: "Name - Character" with dash separator
                    if (entry.includes(' - ')) {
                        const parts = entry.split(' - ').map(s => s.trim());
                        if (parts.length >= 2) {
                            actor = toProperCase(parts[0]);
                            character = parts[1];
                            castMembers.push({ actor, character });
                            return;
                        }
                    }
                    
                    // Check for format: "Name = Character" with equals separator
                    if (entry.includes(' = ')) {
                        const parts = entry.split(' = ').map(s => s.trim());
                        if (parts.length >= 2) {
                            actor = toProperCase(parts[0]);
                            character = parts[1];
                            castMembers.push({ actor, character });
                            return;
                        }
                    }
                    
                    // Check for format: "Name (Role)" with parentheses (but not with colon)
                    if (entry.includes('(') && entry.includes(')') && !entry.includes(':')) {
                        const match = entry.match(/(.+?)\s*\(([^)]+)\)/);
                        if (match) {
                            actor = toProperCase(match[1].trim());
                            character = match[2].trim();
                            castMembers.push({ actor, character });
                            return;
                        }
                    }
                    
                    // Check for format with colon: could be "Actor : Character" or "Character : Actor"
                    if (entry.includes(' : ') || entry.includes(': ')) {
                        const parts = entry.split(/\s*:\s*/).map(s => s.trim());
                        if (parts.length >= 2) {
                            // Heuristic to detect order
                            const firstWords = parts[0].split(/\s+/);
                            const secondWords = parts[1].split(/\s+/);
                            
                            const articles = ['le', 'la', 'les', 'l\'', 'un', 'une', 'the', 'a', 'an'];
                            const firstStartsWithArticle = articles.includes(firstWords[0].toLowerCase());
                            const secondStartsWithArticle = articles.includes(secondWords[0].toLowerCase());
                            
                            const isNameWord = (w) => w.length >= 2 && /^[A-Z√Ä-√ú]/.test(w) && !articles.includes(w.toLowerCase());
                            const firstNameWords = firstWords.filter(isNameWord).length;
                            const secondNameWords = secondWords.filter(isNameWord).length;
                            
                            let isActorFirst = true;
                            
                            if (firstStartsWithArticle && !secondStartsWithArticle) {
                                isActorFirst = false;
                            } else if (secondStartsWithArticle && !firstStartsWithArticle) {
                                isActorFirst = true;
                            } else if (firstNameWords >= 2 && secondNameWords <= 1) {
                                isActorFirst = true;
                            } else if (secondNameWords >= 2 && firstNameWords <= 1) {
                                isActorFirst = false;
                            }
                            
                            if (isActorFirst) {
                                actor = toProperCase(parts[0]);
                                character = parts[1];
                            } else {
                                actor = toProperCase(parts[1]);
                                character = parts[0];
                            }
                            castMembers.push({ actor, character });
                            return;
                        }
                    }
                    
                    // If no separator found, treat it as just an actor name with no character
                    if (entry.trim()) {
                        actor = toProperCase(entry.trim());
                        character = ''; // Empty character name
                        castMembers.push({ actor, character });
                    }
                });
            }
            
            // Generate XML based on schema version
            castMembers.forEach(member => {
                if (useV52Format) {
                    // 5.2 format - simpler structure
                    castXML += `
      <cast_member>
        <display_name>${member.actor}</display_name>
        <character_name>${member.character || ''}</character_name>
      </cast_member>`;
                } else {
                    // 5.3 format - with characters wrapper
                    if (member.character) {
                        castXML += `
      <cast_member>
        <display_name>${member.actor}</display_name>
        <characters>
          <character>
            <reference_id>${sanitizeReferenceId(member.character)}</reference_id>
            <character_name>${member.character}</character_name>
          </character>
        </characters>
      </cast_member>`;
                    } else {
                        // For cast members without character names
                        castXML += `
      <cast_member>
        <display_name>${member.actor}</display_name>
        <characters>
          <character>
            <reference_id></reference_id>
            <character_name></character_name>
          </character>
        </characters>
      </cast_member>`;
                    }
                }
            });
            
            return castXML;
        }

        function parseCrew(crewData) {
            if (!crewData || crewData.length === 0) return '';
            
            // List of production company indicators - must match as whole words
            const productionIndicators = [
                'Productions', 'Production', 'Films', 'Studio', 'Entertainment', 
                'Pictures', 'Cin√©ma', 'Cinema', 'RTBF', 'TV', 'T√©l√©vision',
                'Art', 'Media', 'VOO', 'Be Tv', 'France 2', 'France 3', 'TF1',
                'Canal', 'M6', 'Arte', 'Pan Cin√©ma'
            ];
            
            function isProductionCompany(name) {
                const lower = name.toLowerCase();
                // Match whole words only using word boundary regex
                return productionIndicators.some(ind => {
                    const pattern = new RegExp(`\\b${ind.toLowerCase().replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                    return pattern.test(lower);
                });
            }
            
            // Helper to check if a word is ALL CAPS
            function isWordAllCaps(word) {
                const letters = word.replace(/[^a-zA-Z√Ä-√ø]/g, '');
                return letters.length > 1 && letters === letters.toUpperCase();
            }
            
            // Helper to check if a word starts with uppercase but isn't all caps (typical first name)
            function isFirstNamePattern(word) {
                const letters = word.replace(/[^a-zA-Z√Ä-√ø]/g, '');
                if (letters.length < 2) return false;
                return /^[A-Z√Ä-√ú]/.test(letters) && letters !== letters.toUpperCase();
            }
            
            // Split concatenated names like "Rapha√´le MOUSSAFIR St√©phane KAZANDJAN"
            function splitConcatenatedNames(text) {
                const words = text.trim().split(/\s+/);
                if (words.length < 4) return [text]; // Need at least 4 words for 2 names
                
                const names = [];
                let currentName = [];
                
                for (let i = 0; i < words.length; i++) {
                    const word = words[i];
                    currentName.push(word);
                    
                    // Check if this is an ALL CAPS word followed by a first-name pattern
                    if (i < words.length - 1 && isWordAllCaps(word) && isFirstNamePattern(words[i + 1])) {
                        if (currentName.length >= 2) {
                            names.push(currentName.join(' '));
                            currentName = [];
                        }
                    }
                }
                
                if (currentName.length > 0) {
                    names.push(currentName.join(' '));
                }
                
                return names.length > 0 ? names : [text];
            }
            
            // Aggregate crew members by name
            const crewByName = {};
            
            crewData.forEach(crewEntry => {
                if (!crewEntry.names) return;
                
                // Map to iTunes role
                const itunesRole = mapToItunesRole(crewEntry.role);
                if (!itunesRole) return; // Skip roles that don't map to iTunes
                
                // Split the names by line breaks first
                const lines = crewEntry.names.split(/[\r\n]+/).filter(line => line.trim() !== '');
                
                lines.forEach(line => {
                    line = line.trim();
                    if (!line) return;
                    
                    // Split by comma, double spaces, and ET/AND/&
                    let names = line.split(/,/).flatMap(part => 
                        part.split(/\s{2,}/).flatMap(subpart =>
                            subpart.split(/\s+(?:ET|AND|&)\s+/i)
                        )
                    );
                    
                    // Further split concatenated names like "FirstName LASTNAME FirstName LASTNAME"
                    names = names.flatMap(name => splitConcatenatedNames(name));
                    
                    // Process each name
                    names.forEach(name => {
                        name = name.trim();
                        if (!name) return;
                        
                        // Skip production companies
                        if (isProductionCompany(name)) return;
                        
                        // Skip if all caps and long (likely a company name)
                        if (isAllCaps(name) && name.length > 20) return;
                        
                        // Apply proper case to names
                        const properName = toProperCase(name);
                        
                        if (!crewByName[properName]) {
                            crewByName[properName] = [];
                        }
                        if (!crewByName[properName].includes(itunesRole)) {
                            crewByName[properName].push(itunesRole);
                        }
                    });
                });
            });
            
            // Build XML with aggregated roles
            let crewXML = '';
            Object.entries(crewByName).forEach(([name, roles]) => {
                crewXML += `
      <crew_member>
        <display_name>${name}</display_name>
        <roles>`;
                roles.forEach(role => {
                    crewXML += `
          <role>${role}</role>`;
                });
                crewXML += `
        </roles>
      </crew_member>`;
            });
            
            return crewXML;
        }

        function isAllCaps(str) {
            // Check if string is all uppercase (excluding spaces and special characters)
            const letters = str.replace(/[^a-zA-Z√Ä-√ø]/g, '');
            return letters.length > 0 && letters === letters.toUpperCase();
        }

        // Escape quotes for use in onclick attributes
        function escapeQuotes(str) {
            if (!str) return '';
            return str.replace(/'/g, "\\'").replace(/"/g, '\\"');
        }

        // Fix name in XML (replace incorrect name with TMDB correct name)
        function fixName(type, index, oldName, newName, button) {
            if (!generatedXML) {
                alert('Please generate XML first');
                return;
            }
            
            // Replace the name in the generated XML
            // Create regex that matches the name in display_name tags
            const escapedOldName = oldName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`(<display_name>)${escapedOldName}(</display_name>)`, 'gi');
            
            generatedXML = generatedXML.replace(regex, `$1${newName}$2`);
            
            // Update the XML display
            document.getElementById('xmlOutput').innerHTML = highlightXML(generatedXML);
            
            // Also update the textarea if in edit mode
            const xmlEditor = document.getElementById('xmlEditor');
            if (xmlEditor) {
                xmlEditor.value = generatedXML;
            }
            
            // Update button state
            button.textContent = 'Fixed';
            button.classList.remove('fix');
            button.classList.add('applied');
            button.onclick = null;
            
            // Update the validation item
            const item = button.closest('.validation-item');
            if (item) {
                // Mark name as fixed
                item.dataset.nameFixed = 'true';
                
                // Update the excel-name but preserve any role-tag
                const excelNameEl = item.querySelector('.excel-name');
                const roleTag = excelNameEl ? excelNameEl.querySelector('.role-tag') : null;
                const roleTagHtml = roleTag ? ` ${roleTag.outerHTML}` : '';
                if (excelNameEl) {
                    excelNameEl.innerHTML = newName + roleTagHtml;
                }
                
                const tmdbNameEl = item.querySelector('.tmdb-name');
                if (tmdbNameEl) {
                    // Preserve role-diff if it exists
                    const roleDiffEl = tmdbNameEl.querySelector('.tmdb-role-diff');
                    const roleDiffHtml = roleDiffEl ? ` ${roleDiffEl.outerHTML}` : '';
                    
                    // Update to show matched name
                    tmdbNameEl.className = 'tmdb-match';
                    tmdbNameEl.innerHTML = `‚Ü≥ ${newName}${roleDiffHtml}`;
                }
                
                // Check if there's a fix-role button that hasn't been clicked yet
                const fixRoleBtn = item.querySelector('.validation-btn.fix-role:not(.applied)');
                if (!fixRoleBtn) {
                    // No role button (or already applied), so we're fully done
                    item.classList.remove('accent-warning', 'invalid');
                    item.classList.add('valid');
                    item.querySelector('.validation-status').innerHTML = '<span class="status-ok">‚úì</span>';
                } else if (item.dataset.roleFixed === 'true') {
                    // Both are now fixed
                    item.classList.remove('accent-warning', 'invalid', 'role-warning');
                    item.classList.add('valid');
                    item.querySelector('.validation-status').innerHTML = '<span class="status-ok">‚úì</span>';
                }
                // Otherwise, keep current styling until role is also fixed
            }
        }

        // Translate common English character descriptors to French
        function translateCharacterToFrench(character) {
            if (!character) return character;
            
            const translations = {
                // Age descriptors
                'young': 'jeune',
                'adult': 'adulte',
                'old': 'vieux',
                'older': 'plus √¢g√©',
                'younger': 'plus jeune',
                'child': 'enfant',
                'baby': 'b√©b√©',
                'teenager': 'adolescent',
                'teen': 'ado',
                
                // Family relations
                'father': 'p√®re',
                'mother': 'm√®re',
                'aunt': 'tante',
                'uncle': 'oncle',
                'grandfather': 'grand-p√®re',
                'grandmother': 'grand-m√®re',
                'brother': 'fr√®re',
                'sister': 's≈ìur',
                'son': 'fils',
                'daughter': 'fille',
                'husband': 'mari',
                'wife': 'femme',
                'cousin': 'cousin',
                
                // Common descriptors
                'voice': 'voix',
                'the': 'le'
            };
            
            let result = character;
            
            // Replace whole words only (case-insensitive)
            Object.entries(translations).forEach(([english, french]) => {
                const regex = new RegExp(`\\b${english}\\b`, 'gi');
                result = result.replace(regex, (match) => {
                    // Preserve capitalization
                    if (match[0] === match[0].toUpperCase()) {
                        return french.charAt(0).toUpperCase() + french.slice(1);
                    }
                    return french;
                });
            });
            
            return result;
        }

        // Fix role/character name in XML
        function fixRole(type, personName, oldRole, newRole, button) {
            if (!generatedXML) {
                alert('Please generate XML first');
                return;
            }
            
            const escapedPersonName = personName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const escapedOldRole = oldRole.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            
            if (type === 'cast') {
                // For cast, translate character name to French and replace in XML
                const translatedRole = translateCharacterToFrench(newRole);
                
                // Also update the reference_id to match the new character name
                const newReferenceId = sanitizeReferenceId(translatedRole);
                const oldReferenceId = sanitizeReferenceId(oldRole);
                const escapedOldRefId = oldReferenceId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                
                // First, replace the reference_id
                const refIdRegex = new RegExp(
                    `(<cast_member>[\\s\\S]*?<display_name>${escapedPersonName}</display_name>[\\s\\S]*?<reference_id>)${escapedOldRefId}(</reference_id>[\\s\\S]*?</cast_member>)`,
                    'gi'
                );
                generatedXML = generatedXML.replace(refIdRegex, `$1${newReferenceId}$2`);
                
                // Then, replace the character_name
                const charNameRegex = new RegExp(
                    `(<cast_member>[\\s\\S]*?<display_name>${escapedPersonName}</display_name>[\\s\\S]*?<character_name>)${escapedOldRole}(</character_name>[\\s\\S]*?</cast_member>)`,
                    'gi'
                );
                generatedXML = generatedXML.replace(charNameRegex, `$1${translatedRole}$2`);
                
                // Update newRole for UI display
                newRole = translatedRole;
            } else {
                // For crew, map TMDB role to iTunes-compatible role
                const itunesRole = mapToItunesRole(newRole) || newRole;
                
                // Replace the role within the crew_member block containing this person
                const blockRegex = new RegExp(
                    `(<crew_member>[\\s\\S]*?<display_name>${escapedPersonName}</display_name>[\\s\\S]*?<role>)${escapedOldRole}(</role>[\\s\\S]*?</crew_member>)`,
                    'gi'
                );
                generatedXML = generatedXML.replace(blockRegex, `$1${itunesRole}$2`);
                
                // Update newRole to itunesRole for UI update
                newRole = itunesRole;
            }
            
            // Update the XML display
            document.getElementById('xmlOutput').innerHTML = highlightXML(generatedXML);
            
            // Also update the textarea if in edit mode
            const xmlEditor = document.getElementById('xmlEditor');
            if (xmlEditor) {
                xmlEditor.value = generatedXML;
            }
            
            // Update button state
            button.textContent = 'Fixed';
            button.classList.remove('fix-role');
            button.classList.add('applied');
            button.onclick = null;
            
            // Update the validation item
            const item = button.closest('.validation-item');
            if (item) {
                // Mark role as fixed
                item.dataset.roleFixed = 'true';
                
                // Update role tag to show new role
                const roleTag = item.querySelector('.role-tag');
                if (roleTag) {
                    roleTag.textContent = newRole;
                }
                
                // Update the tmdb-role-diff to tmdb-role
                const tmdbRoleDiff = item.querySelector('.tmdb-role-diff');
                if (tmdbRoleDiff) {
                    tmdbRoleDiff.className = 'tmdb-role';
                    tmdbRoleDiff.textContent = `(${newRole})`;
                }
                
                // Check if there's a fix-name button that hasn't been clicked yet
                const fixNameBtn = item.querySelector('.validation-btn.fix:not(.applied)');
                if (!fixNameBtn) {
                    // No name button (or already applied), so we're fully done
                    item.classList.remove('role-warning', 'accent-warning');
                    item.classList.add('valid');
                    const statusEl = item.querySelector('.validation-status');
                    if (statusEl) {
                        statusEl.innerHTML = '<span class="status-ok">‚úì</span>';
                    }
                } else if (item.dataset.nameFixed === 'true') {
                    // Both are now fixed
                    item.classList.remove('role-warning', 'accent-warning', 'invalid');
                    item.classList.add('valid');
                    const statusEl = item.querySelector('.validation-status');
                    if (statusEl) {
                        statusEl.innerHTML = '<span class="status-ok">‚úì</span>';
                    }
                }
                // Otherwise, keep current styling until name is also fixed
            }
        }

        // Delete name from XML
        function deleteName(type, index, name, button) {
            if (!generatedXML) {
                alert('Please generate XML first');
                return;
            }
            
            const escapedName = name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const tagName = type === 'cast' ? 'cast_member' : 'crew_member';
            
            // Split XML into lines to find and remove the specific block
            const lines = generatedXML.split('\n');
            let newLines = [];
            let inTargetBlock = false;
            let blockDepth = 0;
            let foundName = false;
            let blockStartIndex = -1;
            let tempBlock = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                
                // Check if we're starting a new member block
                if (trimmedLine === `<${tagName}>`) {
                    inTargetBlock = true;
                    blockDepth = 1;
                    foundName = false;
                    blockStartIndex = newLines.length;
                    tempBlock = [line];
                    continue;
                }
                
                if (inTargetBlock) {
                    tempBlock.push(line);
                    
                    // Check if this line contains the target name
                    if (line.includes(`<display_name>${name}</display_name>`)) {
                        foundName = true;
                    }
                    
                    // Check for end of block
                    if (trimmedLine === `</${tagName}>`) {
                        if (foundName) {
                            // Skip this block (don't add it to newLines)
                            inTargetBlock = false;
                            tempBlock = [];
                            continue;
                        } else {
                            // Keep this block
                            newLines = newLines.concat(tempBlock);
                        }
                        inTargetBlock = false;
                        tempBlock = [];
                        continue;
                    }
                } else {
                    newLines.push(line);
                }
            }
            
            generatedXML = newLines.join('\n');
            
            // Update the XML display
            document.getElementById('xmlOutput').innerHTML = highlightXML(generatedXML);
            
            // Also update the textarea if in edit mode
            const xmlEditor = document.getElementById('xmlEditor');
            if (xmlEditor) {
                xmlEditor.value = generatedXML;
            }
            
            // Update button state
            button.textContent = 'Deleted';
            button.classList.remove('delete');
            button.classList.add('applied');
            button.onclick = null;
            
            // Update the validation item
            const item = button.closest('.validation-item');
            if (item) {
                item.style.opacity = '0.5';
                item.style.textDecoration = 'line-through';
            }
        }

        // Add a cast member to the XML
        function addCastMember(name, character, button) {
            if (!generatedXML) {
                alert('Please generate XML first');
                return;
            }
            
            // Translate character name to French
            const translatedCharacter = translateCharacterToFrench(character);
            
            // Determine schema version from XML
            const is52 = generatedXML.includes('version="film5.2"');
            
            // Create the cast member XML
            let castMemberXml;
            if (is52) {
                castMemberXml = `
      <cast_member>
        <display_name>${name}</display_name>
        <character_name>${translatedCharacter}</character_name>
      </cast_member>`;
            } else {
                const referenceId = sanitizeReferenceId(translatedCharacter);
                castMemberXml = `
      <cast_member>
        <display_name>${name}</display_name>
        <characters>
          <character>
            <reference_id>${referenceId}</reference_id>
            <character_name>${translatedCharacter}</character_name>
          </character>
        </characters>
      </cast_member>`;
            }
            
            // Find the </cast> closing tag and insert before it
            const castEndRegex = /(\s*)<\/cast>/;
            if (castEndRegex.test(generatedXML)) {
                generatedXML = generatedXML.replace(castEndRegex, castMemberXml + '\n    </cast>');
            } else {
                alert('Could not find cast section in XML');
                return;
            }
            
            // Update the XML display
            document.getElementById('xmlOutput').innerHTML = highlightXML(generatedXML);
            
            // Also update the textarea if in edit mode
            const xmlEditor = document.getElementById('xmlEditor');
            if (xmlEditor) {
                xmlEditor.value = generatedXML;
            }
            
            // Update button state
            button.textContent = 'Added';
            button.classList.remove('add');
            button.classList.add('applied');
            button.onclick = null;
            
            // Update the validation item
            const item = button.closest('.validation-item');
            if (item) {
                item.classList.remove('suggestion');
                item.classList.add('valid');
                const statusEl = item.querySelector('.validation-status');
                if (statusEl) {
                    statusEl.innerHTML = '<span class="status-ok">‚úì</span>';
                }
            }
        }

        // Add crew member to XML (for TMDB suggestions)
        function addCrewMember(name, role, button) {
            if (!generatedXML) {
                alert('Please generate XML first');
                return;
            }
            
            // Create the crew member XML
            const crewMemberXml = `
      <crew_member>
        <display_name>${name}</display_name>
        <roles>
          <role>${role}</role>
        </roles>
      </crew_member>`;
            
            // Find the </crew> closing tag and insert before it
            const crewEndRegex = /(\s*)<\/crew>/;
            if (crewEndRegex.test(generatedXML)) {
                generatedXML = generatedXML.replace(crewEndRegex, crewMemberXml + '\n    </crew>');
            } else {
                alert('Could not find crew section in XML');
                return;
            }
            
            // Update the XML display
            document.getElementById('xmlOutput').innerHTML = highlightXML(generatedXML);
            
            // Also update the textarea if in edit mode
            const xmlEditor = document.getElementById('xmlEditor');
            if (xmlEditor) {
                xmlEditor.value = generatedXML;
            }
            
            // Update button state
            button.textContent = 'Added';
            button.classList.remove('add');
            button.classList.add('applied');
            button.onclick = null;
            
            // Update the validation item
            const item = button.closest('.validation-item');
            if (item) {
                item.classList.remove('suggestion');
                item.classList.add('valid');
                const statusEl = item.querySelector('.validation-status');
                if (statusEl) {
                    statusEl.innerHTML = '<span class="status-ok">‚úì</span>';
                }
            }
        }

        // Sanitize reference ID: only alphanumeric and underscores allowed
        function sanitizeReferenceId(str) {
            if (!str) return '';
            return str
                .toUpperCase()
                // Handle ligatures that NFD doesn't decompose
                .replace(/≈í/g, 'OE')
                .replace(/≈ì/gi, 'OE')
                .replace(/√Ü/g, 'AE')
                .replace(/√¶/gi, 'AE')
                .replace(/√ü/g, 'SS')
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') // Remove accent marks
                .replace(/[^A-Z0-9\s]/g, '')     // Remove non-alphanumeric except spaces
                .replace(/\s+/g, '_')             // Replace spaces with underscores
                .replace(/_+/g, '_')              // Collapse multiple underscores
                .replace(/^_|_$/g, '');           // Remove leading/trailing underscores
        }

        function escapeXml(unsafe) {
            return unsafe.replace(/[<>&'"]/g, function (c) {
                switch (c) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case '\'': return '&apos;';
                    case '"': return '&quot;';
                }
            });
        }

        function highlightXML(xml) {
            // Escape HTML entities first
            let highlighted = xml
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            // Process the XML in a more structured way
            // Split by tags and process each part
            const parts = highlighted.split(/(&lt;[^&]*&gt;)/g);
            
            highlighted = parts.map((part, index) => {
                // Check if this is a tag
                if (part.startsWith('&lt;')) {
                    // XML declaration
                    if (part.startsWith('&lt;?xml')) {
                        return '<span class="xml-declaration">' + part + '</span>';
                    }
                    // Comment
                    if (part.startsWith('&lt;!--')) {
                        return '<span class="xml-comment">' + part + '</span>';
                    }
                    // Self-closing tag or regular tag
                    return part.replace(/(&lt;\/?)([a-zA-Z_][\w:.-]*)((?:\s+[a-zA-Z_][\w:.-]*(?:\s*=\s*"[^"]*")?)*\s*\/?)(&gt;)/g, 
                        function(match, open, tag, attrs, close) {
                            if (attrs) {
                                attrs = attrs.replace(/([a-zA-Z_][\w:.-]*)(\s*=\s*)"([^"]*)"/g, 
                                    '<span class="xml-attr-name">$1</span>$2<span class="xml-attr-value">"$3"</span>');
                            }
                            return '<span class="xml-tag">' + open + tag + '</span>' + attrs + '<span class="xml-tag">' + close + '</span>';
                        });
                } else {
                    // Text content - only highlight if not just whitespace
                    if (part.trim()) {
                        return '<span class="xml-text">' + part + '</span>';
                    }
                    return part; // Keep whitespace as-is
                }
            }).join('');
            
            return highlighted;
        }

        function generateXML() {
            const movieIndex = document.getElementById('rowSelect').value;
            const movie = processedMovies[movieIndex];
            
            if (!movie) return;
            
            const row = movie.data;
            
            const getValue = (index) => {
                return row[index] || '';
            };
            
            const getMappedValue = (xmlField) => {
                const index = Object.keys(currentMappings).find(key => currentMappings[key] === xmlField);
                if (!index) return '';
                return getValue(parseInt(index));
            };
            
            // Special function to get cast data with roles from adjacent column or separate rows
            const getCastWithRoles = () => {
                // First check if we have cast collected from separate rows (P/Q pattern)
                if (movie.castFromRows && movie.castFromRows.length > 0) {
                    return movie.castFromRows.map(c => 
                        c.character ? `${c.actor} (${c.character})` : c.actor
                    ).join('\n');
                }
                
                const castIndex = Object.keys(currentMappings).find(key => currentMappings[key] === 'cast');
                if (!castIndex) return '';
                
                const castColIndex = parseInt(castIndex);
                const castValue = getValue(castColIndex);
                
                if (!castValue) return '';
                
                // Check if adjacent column (castColIndex + 1) has role data
                const roleColValue = getValue(castColIndex + 1);
                
                // If role column has "R√¥le : " pattern, combine actor + role
                if (roleColValue && roleColValue.includes('R√¥le')) {
                    // Split both columns by newlines
                    const actors = castValue.split(/[\r\n]+/).filter(Boolean);
                    const roles = roleColValue.split(/[\r\n]+/).filter(Boolean);
                    
                    // Combine actor and role for each entry
                    const combined = [];
                    for (let i = 0; i < actors.length; i++) {
                        const actor = actors[i].trim();
                        let role = roles[i] ? roles[i].trim() : '';
                        
                        // Remove "R√¥le : " prefix if present
                        role = role.replace(/^R√¥le\s*:\s*/i, '');
                        
                        if (actor && role) {
                            // Use parentheses format: "Actor (Character)"
                            combined.push(`${actor} (${role})`);
                        } else if (actor) {
                            combined.push(actor);
                        }
                    }
                    return combined.join('\n');
                }
                
                return castValue;
            };
            
            // Get title and apply French title case (only first letter uppercase)
            let title = getMappedValue('title');
            if (title) {
                title = toFrenchTitleCase(title);
            }
            
            // Get studio release title (keep original case for this field)
            let studioTitle = getMappedValue('studio_release_title') || getMappedValue('title');
            // Studio release title can keep mixed case or be normalized
            if (studioTitle && isAllCaps(studioTitle)) {
                studioTitle = toFrenchTitleCase(studioTitle);
            }
            
            // Get original spoken locale and convert to RFC5646 format
            let originalSpokenLocale = getMappedValue('original_spoken_locale') || getMappedValue('language');
            originalSpokenLocale = toRFC5646Locale(originalSpokenLocale);
            
            // Check production company - skip if all caps
            let productionCompany = getMappedValue('production_company');
            if (productionCompany && isAllCaps(productionCompany)) {
                productionCompany = '';
            }
            
            // Build crew XML from collected crew data
            const crewXML = parseCrew(movie.crew);
            
            // Get preorder date
            const preorderDate = getMappedValue('preorder_date');
            
            // Get country value
            const country = getMappedValue('country');
            
            // Get physical release date, fallback to VOD start date if empty
            let physicalRelease = getMappedValue('physical_release');
            const vodStart = getMappedValue('vod_start');
            if (!physicalRelease && vodStart) {
                physicalRelease = vodStart;
            }
            
            // Generate different XML based on schema version
            let xml = '';
            if (schemaVersion === '5.2') {
                // Version 5.2 format
                xml = `<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://apple.com/itunes/importer" version="film5.2">
  <provider>${getMappedValue('provider')}</provider>
  <language>${getMappedValue('language')}</language>
  <video>
    <type>${getMappedValue('video_type')}</type>
    <subtype>${getMappedValue('video_subtype')}</subtype>
    <vendor_id>${getMappedValue('vendor_id')}</vendor_id>
    <isan></isan>
    <country>${country}</country>
    <original_spoken_locale>${originalSpokenLocale}</original_spoken_locale>
    <title>${title}</title>
    <studio_release_title>${studioTitle}</studio_release_title>
    <synopsis>${normalizeSynopsis(getMappedValue('synopsis'))}</synopsis>${productionCompany ? `
    <production_company>${productionCompany}</production_company>` : ''}
    <copyright_cline>${cleanCopyright(getMappedValue('copyright'))}</copyright_cline>
    <theatrical_release_date>${formatDate(getMappedValue('theatrical_release'))}</theatrical_release_date>
    <genres>${parseGenres(getMappedValue('genre'))}
    </genres>
    <ratings>
      <rating system="fr-cnc" code="${parseRating(getMappedValue('rating'))}"/>
    </ratings>
    <regions>
      <region>
        <territory>${getMappedValue('territory')}</territory>
        <theatrical_release_date>${formatDate(getMappedValue('theatrical_release'))}</theatrical_release_date>
      </region>
    </regions>
    <cast>${parseCast(getCastWithRoles(), true)}
    </cast>
    <crew>${crewXML}
    </crew>
    <products>
      <product>
        <territory>${getMappedValue('territory')}</territory>
        <cleared_for_sale>${getMappedValue('cleared_sale') || 'true'}</cleared_for_sale>
        <cleared_for_hd_sale>${getMappedValue('cleared_sale') || 'true'}</cleared_for_hd_sale>
        <wholesale_price_tier>8</wholesale_price_tier>
        <hd_wholesale_price_tier>108</hd_wholesale_price_tier>${preorderDate ? `
        <preorder_sales_start_date>${formatDate(preorderDate)}</preorder_sales_start_date>` : ''}
        <sales_start_date>${formatDate(getMappedValue('sales_start'))}</sales_start_date>
        <sales_end_date>${formatDate(getMappedValue('sales_end'))}</sales_end_date>
        <cleared_for_vod>${getMappedValue('cleared_vod') || 'true'}</cleared_for_vod>
        <cleared_for_hd_vod>${getMappedValue('cleared_hd_vod') || 'true'}</cleared_for_hd_vod>
        <vod_type>Tier 2</vod_type>
        <available_for_vod_date>${formatDate(getMappedValue('vod_start'))}</available_for_vod_date>
        <unavailable_for_vod_date>${formatDate(getMappedValue('vod_end'))}</unavailable_for_vod_date>
        <physical_release_date>${formatDate(physicalRelease)}</physical_release_date>
      </product>
    </products>
  </video>
</package>`;
            } else {
                // Version 5.3 format (default)
                xml = `<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://apple.com/itunes/importer" version="film5.3">
  <provider>${getMappedValue('provider')}</provider>
  <language>${getMappedValue('language')}</language>
  <video>
    <type>${getMappedValue('video_type')}</type>
    <subtype>${getMappedValue('video_subtype')}</subtype>
    <vendor_id>${getMappedValue('vendor_id')}</vendor_id>
    <isan></isan>
    <countries_of_origin>
      <country primary="true">${country}</country>
    </countries_of_origin>
    <production_countries>
      <country primary="true">${country}</country>
    </production_countries>
    <original_spoken_locale>${originalSpokenLocale}</original_spoken_locale>
    <title>${title}</title>
    <studio_release_title>${studioTitle}</studio_release_title>
    <synopsis>${normalizeSynopsis(getMappedValue('synopsis'))}</synopsis>${productionCompany ? `
    <production_company>${productionCompany}</production_company>` : ''}
    <copyright_cline>${cleanCopyright(getMappedValue('copyright'))}</copyright_cline>
    <theatrical_release_date>${formatDate(getMappedValue('theatrical_release'))}</theatrical_release_date>
    <genres>${parseGenres(getMappedValue('genre'))}
    </genres>
    <ratings>
      <rating system="fr-cnc" code="${parseRating(getMappedValue('rating'))}"/>
    </ratings>
    <regions>
      <region>
        <territory>${getMappedValue('territory')}</territory>
        <theatrical_release_date>${formatDate(getMappedValue('theatrical_release'))}</theatrical_release_date>
      </region>
    </regions>
    <cast>${parseCast(getCastWithRoles(), false)}
    </cast>
    <crew>${crewXML}
    </crew>
    <products>
      <product>
        <territory>${getMappedValue('territory')}</territory>
        <cleared_for_sale>${getMappedValue('cleared_sale') || 'true'}</cleared_for_sale>
        <cleared_for_hd_sale>${getMappedValue('cleared_sale') || 'true'}</cleared_for_hd_sale>
        <wholesale_price_tier>8</wholesale_price_tier>
        <hd_wholesale_price_tier>108</hd_wholesale_price_tier>${preorderDate ? `
        <preorder_sales_start_date>${formatDate(preorderDate)}</preorder_sales_start_date>` : ''}
        <sales_start_date>${formatDate(getMappedValue('sales_start'))}</sales_start_date>
        <sales_end_date>${formatDate(getMappedValue('sales_end'))}</sales_end_date>
        <cleared_for_vod>${getMappedValue('cleared_vod') || 'true'}</cleared_for_vod>
        <cleared_for_hd_vod>${getMappedValue('cleared_hd_vod') || 'true'}</cleared_for_hd_vod>
        <vod_type>Tier 2</vod_type>
        <available_for_vod_date>${formatDate(getMappedValue('vod_start'))}</available_for_vod_date>
        <unavailable_for_vod_date>${formatDate(getMappedValue('vod_end'))}</unavailable_for_vod_date>
        <physical_release_date>${formatDate(physicalRelease)}</physical_release_date>
      </product>
    </products>
  </video>
</package>`;
            }
            
            generatedXML = xml;
            
            // Reset to preview mode if in edit mode
            if (isEditMode) {
                const toggle = document.getElementById('editToggle');
                const wrapper = document.querySelector('.xml-output-wrapper');
                toggle.classList.remove('active');
                wrapper.classList.remove('edit-mode');
                document.getElementById('previewLabel').classList.add('active');
                document.getElementById('editLabel').classList.remove('active');
                document.getElementById('xmlEditor').classList.add('hidden');
                isEditMode = false;
            }
            
            // Apply syntax highlighting to preview
            document.getElementById('xmlOutput').innerHTML = highlightXML(xml);
            // Also populate editor for when user switches to edit mode
            document.getElementById('xmlEditor').value = xml;
            document.getElementById('outputSection').classList.remove('hidden');
            
            // Enable the validate button
            const validateBtn = document.getElementById('validateBtn');
            if (validateBtn) {
                validateBtn.disabled = false;
            }
            
            // Scroll to output
            document.getElementById('outputSection').scrollIntoView({ behavior: 'smooth' });
        }

        function downloadXML() {
            // Get the XML content - use editor content if in edit mode
            let xmlContent = generatedXML;
            if (isEditMode) {
                xmlContent = document.getElementById('xmlEditor').value;
                generatedXML = xmlContent; // Update the stored XML
            }
            
            if (!xmlContent) return;
            
            const blob = new Blob([xmlContent], { type: 'text/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // Get the metadata for filename
            const movieIndex = document.getElementById('rowSelect').value;
            const movie = processedMovies[movieIndex];
            const row = movie.data;
            
            const provider = row[1] || 'Provider'; // Column B
            const vendorId = row[4] || 'VendorID'; // Column E
            const title = movie.title || 'metadata';
            
            // Format: Provider_vendorID_Title_metadata.xml
            a.download = `${provider}_${vendorId}_${title.replace(/[^a-z0-9]/gi, '_')}_metadata.xml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
